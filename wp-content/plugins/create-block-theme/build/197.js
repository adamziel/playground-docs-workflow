"use strict";(globalThis.webpackChunkcreate_block_theme=globalThis.webpackChunkcreate_block_theme||[]).push([[197],{7879:(t,s,e)=>{e.d(s,{P:()=>i});var r=e(6770);class i extends r.j{constructor(t){super(t),this.coverageFormat=t.uint16,1===this.coverageFormat&&(this.glyphCount=t.uint16,this.glyphArray=[...new Array(this.glyphCount)].map((s=>t.uint16))),2===this.coverageFormat&&(this.rangeCount=t.uint16,this.rangeRecords=[...new Array(this.rangeCount)].map((s=>new n(t))))}}class n{constructor(t){this.startGlyphID=t.uint16,this.endGlyphID=t.uint16,this.startCoverageIndex=t.uint16}}},197:(t,s,e)=>{e.d(s,{L:()=>et});var r=e(2592),i=e(6770);class n extends i.j{static EMPTY={scriptCount:0,scriptRecords:[]};constructor(t){super(t),this.scriptCount=t.uint16,this.scriptRecords=[...new Array(this.scriptCount)].map((s=>new u(t)))}}class u{constructor(t){this.scriptTag=t.tag,this.scriptOffset=t.Offset16}}class a extends i.j{constructor(t){super(t),this.defaultLangSys=t.Offset16,this.langSysCount=t.uint16,this.langSysRecords=[...new Array(this.langSysCount)].map((s=>new o(t)))}}class o{constructor(t){this.langSysTag=t.tag,this.langSysOffset=t.Offset16}}class h{constructor(t){this.lookupOrder=t.Offset16,this.requiredFeatureIndex=t.uint16,this.featureIndexCount=t.uint16,this.featureIndices=[...new Array(this.featureIndexCount)].map((s=>t.uint16))}}class c extends i.j{static EMPTY={featureCount:0,featureRecords:[]};constructor(t){super(t),this.featureCount=t.uint16,this.featureRecords=[...new Array(this.featureCount)].map((s=>new l(t)))}}class l{constructor(t){this.featureTag=t.tag,this.featureOffset=t.Offset16}}class p extends i.j{constructor(t){super(t),this.featureParams=t.Offset16,this.lookupIndexCount=t.uint16,this.lookupListIndices=[...new Array(this.lookupIndexCount)].map((s=>t.uint16))}getFeatureParams(){if(this.featureParams>0){const t=this.parser;t.currentPosition=this.start+this.featureParams;const s=this.featureTag;if("size"===s)return new g(t);if(s.startsWith("cc"))return new f(t);if(s.startsWith("ss"))return new b(t)}}}class f{constructor(t){this.format=t.uint16,this.featUiLabelNameId=t.uint16,this.featUiTooltipTextNameId=t.uint16,this.sampleTextNameId=t.uint16,this.numNamedParameters=t.uint16,this.firstParamUiLabelNameId=t.uint16,this.charCount=t.uint16,this.character=[...new Array(this.charCount)].map((s=>t.uint24))}}class g{constructor(t){this.designSize=t.uint16,this.subfamilyIdentifier=t.uint16,this.subfamilyNameID=t.uint16,this.smallEnd=t.uint16,this.largeEnd=t.uint16}}class b{constructor(t){this.version=t.uint16,this.UINameID=t.uint16}}var y=e(7879);function C(t){t.parser.currentPosition-=2,delete t.coverageOffset,delete t.getCoverageTable}class d extends i.j{constructor(t){super(t),this.substFormat=t.uint16,this.coverageOffset=t.Offset16}getCoverageTable(){let t=this.parser;return t.currentPosition=this.start+this.coverageOffset,new y.P(t)}}class m{constructor(t){this.glyphSequenceIndex=t.uint16,this.lookupListIndex=t.uint16}}class k extends d{constructor(t){super(t),this.deltaGlyphID=t.int16}}class S extends d{constructor(t){super(t),this.sequenceCount=t.uint16,this.sequenceOffsets=[...new Array(this.sequenceCount)].map((s=>t.Offset16))}getSequence(t){let s=this.parser;return s.currentPosition=this.start+this.sequenceOffsets[t],new O(s)}}class O{constructor(t){this.glyphCount=t.uint16,this.substituteGlyphIDs=[...new Array(this.glyphCount)].map((s=>t.uint16))}}class w extends d{constructor(t){super(t),this.alternateSetCount=t.uint16,this.alternateSetOffsets=[...new Array(this.alternateSetCount)].map((s=>t.Offset16))}getAlternateSet(t){let s=this.parser;return s.currentPosition=this.start+this.alternateSetOffsets[t],new x(s)}}class x{constructor(t){this.glyphCount=t.uint16,this.alternateGlyphIDs=[...new Array(this.glyphCount)].map((s=>t.uint16))}}class A extends d{constructor(t){super(t),this.ligatureSetCount=t.uint16,this.ligatureSetOffsets=[...new Array(this.ligatureSetCount)].map((s=>t.Offset16))}getLigatureSet(t){let s=this.parser;return s.currentPosition=this.start+this.ligatureSetOffsets[t],new T(s)}}class T extends i.j{constructor(t){super(t),this.ligatureCount=t.uint16,this.ligatureOffsets=[...new Array(this.ligatureCount)].map((s=>t.Offset16))}getLigature(t){let s=this.parser;return s.currentPosition=this.start+this.ligatureOffsets[t],new L(s)}}class L{constructor(t){this.ligatureGlyph=t.uint16,this.componentCount=t.uint16,this.componentGlyphIDs=[...new Array(this.componentCount-1)].map((s=>t.uint16))}}class R extends d{constructor(t){super(t),1===this.substFormat&&(this.subRuleSetCount=t.uint16,this.subRuleSetOffsets=[...new Array(this.subRuleSetCount)].map((s=>t.Offset16))),2===this.substFormat&&(this.classDefOffset=t.Offset16,this.subClassSetCount=t.uint16,this.subClassSetOffsets=[...new Array(this.subClassSetCount)].map((s=>t.Offset16))),3===this.substFormat&&(C(this),this.glyphCount=t.uint16,this.substitutionCount=t.uint16,this.coverageOffsets=[...new Array(this.glyphCount)].map((s=>t.Offset16)),this.substLookupRecords=[...new Array(this.substitutionCount)].map((s=>new m(t))))}getSubRuleSet(t){if(1!==this.substFormat)throw new Error(`lookup type 5.${this.substFormat} has no subrule sets.`);let s=this.parser;return s.currentPosition=this.start+this.subRuleSetOffsets[t],new P(s)}getSubClassSet(t){if(2!==this.substFormat)throw new Error(`lookup type 5.${this.substFormat} has no subclass sets.`);let s=this.parser;return s.currentPosition=this.start+this.subClassSetOffsets[t],new G(s)}getCoverageTable(t){if(3!==this.substFormat&&!t)return super.getCoverageTable();if(!t)throw new Error(`lookup type 5.${this.substFormat} requires an coverage table index.`);let s=this.parser;return s.currentPosition=this.start+this.coverageOffsets[t],new y.P(s)}}class P extends i.j{constructor(t){super(t),this.subRuleCount=t.uint16,this.subRuleOffsets=[...new Array(this.subRuleCount)].map((s=>t.Offset16))}getSubRule(t){let s=this.parser;return s.currentPosition=this.start+this.subRuleOffsets[t],new F(s)}}class F{constructor(t){this.glyphCount=t.uint16,this.substitutionCount=t.uint16,this.inputSequence=[...new Array(this.glyphCount-1)].map((s=>t.uint16)),this.substLookupRecords=[...new Array(this.substitutionCount)].map((s=>new m(t)))}}class G extends i.j{constructor(t){super(t),this.subClassRuleCount=t.uint16,this.subClassRuleOffsets=[...new Array(this.subClassRuleCount)].map((s=>t.Offset16))}getSubClass(t){let s=this.parser;return s.currentPosition=this.start+this.subClassRuleOffsets[t],new I(s)}}class I extends F{constructor(t){super(t)}}class v extends d{constructor(t){super(t),1===this.substFormat&&(this.chainSubRuleSetCount=t.uint16,this.chainSubRuleSetOffsets=[...new Array(this.chainSubRuleSetCount)].map((s=>t.Offset16))),2===this.substFormat&&(this.backtrackClassDefOffset=t.Offset16,this.inputClassDefOffset=t.Offset16,this.lookaheadClassDefOffset=t.Offset16,this.chainSubClassSetCount=t.uint16,this.chainSubClassSetOffsets=[...new Array(this.chainSubClassSetCount)].map((s=>t.Offset16))),3===this.substFormat&&(C(this),this.backtrackGlyphCount=t.uint16,this.backtrackCoverageOffsets=[...new Array(this.backtrackGlyphCount)].map((s=>t.Offset16)),this.inputGlyphCount=t.uint16,this.inputCoverageOffsets=[...new Array(this.inputGlyphCount)].map((s=>t.Offset16)),this.lookaheadGlyphCount=t.uint16,this.lookaheadCoverageOffsets=[...new Array(this.lookaheadGlyphCount)].map((s=>t.Offset16)),this.seqLookupCount=t.uint16,this.seqLookupRecords=[...new Array(this.substitutionCount)].map((s=>new V(t))))}getChainSubRuleSet(t){if(1!==this.substFormat)throw new Error(`lookup type 6.${this.substFormat} has no chainsubrule sets.`);let s=this.parser;return s.currentPosition=this.start+this.chainSubRuleSetOffsets[t],new j(s)}getChainSubClassSet(t){if(2!==this.substFormat)throw new Error(`lookup type 6.${this.substFormat} has no chainsubclass sets.`);let s=this.parser;return s.currentPosition=this.start+this.chainSubClassSetOffsets[t],new D(s)}getCoverageFromOffset(t){if(3!==this.substFormat)throw new Error(`lookup type 6.${this.substFormat} does not use contextual coverage offsets.`);let s=this.parser;return s.currentPosition=this.start+t,new y.P(s)}}class j extends i.j{constructor(t){super(t),this.chainSubRuleCount=t.uint16,this.chainSubRuleOffsets=[...new Array(this.chainSubRuleCount)].map((s=>t.Offset16))}getSubRule(t){let s=this.parser;return s.currentPosition=this.start+this.chainSubRuleOffsets[t],new q(s)}}class q{constructor(t){this.backtrackGlyphCount=t.uint16,this.backtrackSequence=[...new Array(this.backtrackGlyphCount)].map((s=>t.uint16)),this.inputGlyphCount=t.uint16,this.inputSequence=[...new Array(this.inputGlyphCount-1)].map((s=>t.uint16)),this.lookaheadGlyphCount=t.uint16,this.lookAheadSequence=[...new Array(this.lookAheadGlyphCount)].map((s=>t.uint16)),this.substitutionCount=t.uint16,this.substLookupRecords=[...new Array(this.SubstCount)].map((s=>new m(t)))}}class D extends i.j{constructor(t){super(t),this.chainSubClassRuleCount=t.uint16,this.chainSubClassRuleOffsets=[...new Array(this.chainSubClassRuleCount)].map((s=>t.Offset16))}getSubClass(t){let s=this.parser;return s.currentPosition=this.start+this.chainSubRuleOffsets[t],new E(s)}}class E{constructor(t){this.backtrackGlyphCount=t.uint16,this.backtrackSequence=[...new Array(this.backtrackGlyphCount)].map((s=>t.uint16)),this.inputGlyphCount=t.uint16,this.inputSequence=[...new Array(this.inputGlyphCount-1)].map((s=>t.uint16)),this.lookaheadGlyphCount=t.uint16,this.lookAheadSequence=[...new Array(this.lookAheadGlyphCount)].map((s=>t.uint16)),this.substitutionCount=t.uint16,this.substLookupRecords=[...new Array(this.substitutionCount)].map((s=>new V(t)))}}class V extends i.j{constructor(t){super(t),this.sequenceIndex=t.uint16,this.lookupListIndex=t.uint16}}class M extends i.j{constructor(t){super(t),this.substFormat=t.uint16,this.extensionLookupType=t.uint16,this.extensionOffset=t.Offset32}}class N extends d{constructor(t){super(t),this.backtrackGlyphCount=t.uint16,this.backtrackCoverageOffsets=[...new Array(this.backtrackGlyphCount)].map((s=>t.Offset16)),this.lookaheadGlyphCount=t.uint16,this.lookaheadCoverageOffsets=[new Array(this.lookaheadGlyphCount)].map((s=>t.Offset16)),this.glyphCount=t.uint16,this.substituteGlyphIDs=[...new Array(this.glyphCount)].map((s=>t.uint16))}}const Y={buildSubtable:function(t,s){const e=new[void 0,k,S,w,A,R,v,M,N][t](s);return e.type=t,e}};class $ extends i.j{constructor(t){super(t)}}class U extends ${constructor(t){super(t),console.log("lookup type 1")}}class Z extends ${constructor(t){super(t),console.log("lookup type 2")}}class _ extends ${constructor(t){super(t),console.log("lookup type 3")}}class z extends ${constructor(t){super(t),console.log("lookup type 4")}}class B extends ${constructor(t){super(t),console.log("lookup type 5")}}class W extends ${constructor(t){super(t),console.log("lookup type 6")}}class H extends ${constructor(t){super(t),console.log("lookup type 7")}}class J extends ${constructor(t){super(t),console.log("lookup type 8")}}class K extends ${constructor(t){super(t),console.log("lookup type 9")}}const Q={buildSubtable:function(t,s){const e=new[void 0,U,Z,_,z,B,W,H,J,K][t](s);return e.type=t,e}};class X extends i.j{static EMPTY={lookupCount:0,lookups:[]};constructor(t){super(t),this.lookupCount=t.uint16,this.lookups=[...new Array(this.lookupCount)].map((s=>t.Offset16))}}class tt extends i.j{constructor(t,s){super(t),this.ctType=s,this.lookupType=t.uint16,this.lookupFlag=t.uint16,this.subTableCount=t.uint16,this.subtableOffsets=[...new Array(this.subTableCount)].map((s=>t.Offset16)),this.markFilteringSet=t.uint16}get rightToLeft(){return!0&this.lookupFlag}get ignoreBaseGlyphs(){return!0&this.lookupFlag}get ignoreLigatures(){return!0&this.lookupFlag}get ignoreMarks(){return!0&this.lookupFlag}get useMarkFilteringSet(){return!0&this.lookupFlag}get markAttachmentType(){return!0&this.lookupFlag}getSubTable(t){const s="GSUB"===this.ctType?Y:Q;return this.parser.currentPosition=this.start+this.subtableOffsets[t],s.buildSubtable(this.lookupType,this.parser)}}var st=e(7047);class et extends r.x{constructor(t,s,e){const{p:r,tableStart:i}=super(t,s,e);this.majorVersion=r.uint16,this.minorVersion=r.uint16,this.scriptListOffset=r.Offset16,this.featureListOffset=r.Offset16,this.lookupListOffset=r.Offset16,1===this.majorVersion&&1===this.minorVersion&&(this.featureVariationsOffset=r.Offset32);const u=!(this.scriptListOffset||this.featureListOffset||this.lookupListOffset);(0,st.Z)(this,"scriptList",(()=>u?n.EMPTY:(r.currentPosition=i+this.scriptListOffset,new n(r)))),(0,st.Z)(this,"featureList",(()=>u?c.EMPTY:(r.currentPosition=i+this.featureListOffset,new c(r)))),(0,st.Z)(this,"lookupList",(()=>u?X.EMPTY:(r.currentPosition=i+this.lookupListOffset,new X(r)))),this.featureVariationsOffset&&(0,st.Z)(this,"featureVariations",(()=>u?FeatureVariations.EMPTY:(r.currentPosition=i+this.featureVariationsOffset,new FeatureVariations(r))))}getSupportedScripts(){return this.scriptList.scriptRecords.map((t=>t.scriptTag))}getScriptTable(t){let s=this.scriptList.scriptRecords.find((s=>s.scriptTag===t));this.parser.currentPosition=this.scriptList.start+s.scriptOffset;let e=new a(this.parser);return e.scriptTag=t,e}ensureScriptTable(t){return"string"==typeof t?this.getScriptTable(t):t}getSupportedLangSys(t){const s=0!==(t=this.ensureScriptTable(t)).defaultLangSys,e=t.langSysRecords.map((t=>t.langSysTag));return s&&e.unshift("dflt"),e}getDefaultLangSysTable(t){let s=(t=this.ensureScriptTable(t)).defaultLangSys;if(0!==s){this.parser.currentPosition=t.start+s;let e=new h(this.parser);return e.langSysTag="",e.defaultForScript=t.scriptTag,e}}getLangSysTable(t,s="dflt"){if("dflt"===s)return this.getDefaultLangSysTable(t);let e=(t=this.ensureScriptTable(t)).langSysRecords.find((t=>t.langSysTag===s));this.parser.currentPosition=t.start+e.langSysOffset;let r=new h(this.parser);return r.langSysTag=s,r}getFeatures(t){return t.featureIndices.map((t=>this.getFeature(t)))}getFeature(t){let s;if(s=parseInt(t)==t?this.featureList.featureRecords[t]:this.featureList.featureRecords.find((s=>s.featureTag===t)),!s)return;this.parser.currentPosition=this.featureList.start+s.featureOffset;let e=new p(this.parser);return e.featureTag=s.featureTag,e}getLookups(t){return t.lookupListIndices.map((t=>this.getLookup(t)))}getLookup(t,s){let e=this.lookupList.lookups[t];return this.parser.currentPosition=this.lookupList.start+e,new tt(this.parser,s)}}}}]);