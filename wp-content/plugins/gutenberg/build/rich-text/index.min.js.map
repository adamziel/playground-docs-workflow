{"version":3,"file":"./build/rich-text/index.min.js","mappings":"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","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/compat get default export","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","webpack://wp/external window [\"wp\",\"data\"]","../../packages/rich-text/src/store/reducer.js","webpack://wp/./node_modules/rememo/rememo.js","../../packages/rich-text/src/store/selectors.js","../../packages/rich-text/src/store/actions.js","../../packages/rich-text/src/store/index.js","../../packages/rich-text/src/is-format-equal.js","../../packages/rich-text/src/normalise-formats.js","../../packages/rich-text/src/apply-format.js","../../packages/rich-text/src/create-element.js","../../packages/rich-text/src/special-characters.js","webpack://wp/external window [\"wp\",\"escapeHtml\"]","../../packages/rich-text/src/get-active-formats.js","../../packages/rich-text/src/get-format-type.js","../../packages/rich-text/src/to-tree.js","../../packages/rich-text/src/to-html-string.js","../../packages/rich-text/src/get-text-content.js","../../packages/rich-text/src/create.js","../../packages/rich-text/src/concat.js","../../packages/rich-text/src/get-active-format.js","../../packages/rich-text/src/get-active-object.js","../../packages/rich-text/src/is-collapsed.ts","../../packages/rich-text/src/is-empty.js","../../packages/rich-text/src/join.js","../../packages/rich-text/src/register-format-type.js","../../packages/rich-text/src/remove-format.js","../../packages/rich-text/src/insert.js","../../packages/rich-text/src/remove.js","../../packages/rich-text/src/replace.js","../../packages/rich-text/src/insert-object.js","../../packages/rich-text/src/slice.js","../../packages/rich-text/src/split.js","../../packages/rich-text/src/is-range-equal.js","../../packages/rich-text/src/to-dom.js","webpack://wp/external window [\"wp\",\"a11y\"]","webpack://wp/external window [\"wp\",\"i18n\"]","../../packages/rich-text/src/toggle-format.js","../../packages/rich-text/src/unregister-format-type.js","webpack://wp/external window [\"wp\",\"element\"]","webpack://wp/external window [\"wp\",\"deprecated\"]","../../packages/rich-text/src/component/use-anchor-ref.js","webpack://wp/external window [\"wp\",\"compose\"]","../../packages/rich-text/src/component/use-anchor.js","../../packages/rich-text/src/component/use-default-style.js","../../packages/rich-text/src/component/use-boundary-style.js","../../packages/rich-text/src/component/use-copy-handler.js","webpack://wp/external window [\"wp\",\"keycodes\"]","../../packages/rich-text/src/component/use-format-boundaries.js","../../packages/rich-text/src/component/use-input-and-selection.js","../../packages/rich-text/src/update-formats.js","../../packages/rich-text/src/component/use-delete.js","../../packages/rich-text/src/component/index.js","../../packages/rich-text/src/component/use-select-object.js","../../packages/rich-text/src/component/use-selection-change-compat.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"data\"];","/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Reducer managing the format types\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Updated state.\n */\nexport function formatTypes( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'ADD_FORMAT_TYPES':\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t// Key format types by their name.\n\t\t\t\t...action.formatTypes.reduce(\n\t\t\t\t\t( newFormatTypes, type ) => ( {\n\t\t\t\t\t\t...newFormatTypes,\n\t\t\t\t\t\t[ type.name ]: type,\n\t\t\t\t\t} ),\n\t\t\t\t\t{}\n\t\t\t\t),\n\t\t\t};\n\t\tcase 'REMOVE_FORMAT_TYPES':\n\t\t\treturn Object.fromEntries(\n\t\t\t\tObject.entries( state ).filter(\n\t\t\t\t\t( [ key ] ) => ! action.names.includes( key )\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\treturn state;\n}\n\nexport default combineReducers( { formatTypes } );\n","'use strict';\n\n/** @typedef {(...args: any[]) => *[]} GetDependants */\n\n/** @typedef {() => void} Clear */\n\n/**\n * @typedef {{\n *   getDependants: GetDependants,\n *   clear: Clear\n * }} EnhancedSelector\n */\n\n/**\n * Internal cache entry.\n *\n * @typedef CacheNode\n *\n * @property {?CacheNode|undefined} [prev] Previous node.\n * @property {?CacheNode|undefined} [next] Next node.\n * @property {*[]} args Function arguments for cache entry.\n * @property {*} val Function result.\n */\n\n/**\n * @typedef Cache\n *\n * @property {Clear} clear Function to clear cache.\n * @property {boolean} [isUniqueByDependants] Whether dependants are valid in\n * considering cache uniqueness. A cache is unique if dependents are all arrays\n * or objects.\n * @property {CacheNode?} [head] Cache head.\n * @property {*[]} [lastDependants] Dependants from previous invocation.\n */\n\n/**\n * Arbitrary value used as key for referencing cache object in WeakMap tree.\n *\n * @type {{}}\n */\nvar LEAF_KEY = {};\n\n/**\n * Returns the first argument as the sole entry in an array.\n *\n * @template T\n *\n * @param {T} value Value to return.\n *\n * @return {[T]} Value returned as entry in array.\n */\nfunction arrayOf(value) {\n\treturn [value];\n}\n\n/**\n * Returns true if the value passed is object-like, or false otherwise. A value\n * is object-like if it can support property assignment, e.g. object or array.\n *\n * @param {*} value Value to test.\n *\n * @return {boolean} Whether value is object-like.\n */\nfunction isObjectLike(value) {\n\treturn !!value && 'object' === typeof value;\n}\n\n/**\n * Creates and returns a new cache object.\n *\n * @return {Cache} Cache object.\n */\nfunction createCache() {\n\t/** @type {Cache} */\n\tvar cache = {\n\t\tclear: function () {\n\t\t\tcache.head = null;\n\t\t},\n\t};\n\n\treturn cache;\n}\n\n/**\n * Returns true if entries within the two arrays are strictly equal by\n * reference from a starting index.\n *\n * @param {*[]} a First array.\n * @param {*[]} b Second array.\n * @param {number} fromIndex Index from which to start comparison.\n *\n * @return {boolean} Whether arrays are shallowly equal.\n */\nfunction isShallowEqual(a, b, fromIndex) {\n\tvar i;\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (i = fromIndex; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Returns a memoized selector function. The getDependants function argument is\n * called before the memoized selector and is expected to return an immutable\n * reference or array of references on which the selector depends for computing\n * its own return value. The memoize cache is preserved only as long as those\n * dependant references remain the same. If getDependants returns a different\n * reference(s), the cache is cleared and the selector value regenerated.\n *\n * @template {(...args: *[]) => *} S\n *\n * @param {S} selector Selector function.\n * @param {GetDependants=} getDependants Dependant getter returning an array of\n * references used in cache bust consideration.\n */\nexport default function (selector, getDependants) {\n\t/** @type {WeakMap<*,*>} */\n\tvar rootCache;\n\n\t/** @type {GetDependants} */\n\tvar normalizedGetDependants = getDependants ? getDependants : arrayOf;\n\n\t/**\n\t * Returns the cache for a given dependants array. When possible, a WeakMap\n\t * will be used to create a unique cache for each set of dependants. This\n\t * is feasible due to the nature of WeakMap in allowing garbage collection\n\t * to occur on entries where the key object is no longer referenced. Since\n\t * WeakMap requires the key to be an object, this is only possible when the\n\t * dependant is object-like. The root cache is created as a hierarchy where\n\t * each top-level key is the first entry in a dependants set, the value a\n\t * WeakMap where each key is the next dependant, and so on. This continues\n\t * so long as the dependants are object-like. If no dependants are object-\n\t * like, then the cache is shared across all invocations.\n\t *\n\t * @see isObjectLike\n\t *\n\t * @param {*[]} dependants Selector dependants.\n\t *\n\t * @return {Cache} Cache object.\n\t */\n\tfunction getCache(dependants) {\n\t\tvar caches = rootCache,\n\t\t\tisUniqueByDependants = true,\n\t\t\ti,\n\t\t\tdependant,\n\t\t\tmap,\n\t\t\tcache;\n\n\t\tfor (i = 0; i < dependants.length; i++) {\n\t\t\tdependant = dependants[i];\n\n\t\t\t// Can only compose WeakMap from object-like key.\n\t\t\tif (!isObjectLike(dependant)) {\n\t\t\t\tisUniqueByDependants = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Does current segment of cache already have a WeakMap?\n\t\t\tif (caches.has(dependant)) {\n\t\t\t\t// Traverse into nested WeakMap.\n\t\t\t\tcaches = caches.get(dependant);\n\t\t\t} else {\n\t\t\t\t// Create, set, and traverse into a new one.\n\t\t\t\tmap = new WeakMap();\n\t\t\t\tcaches.set(dependant, map);\n\t\t\t\tcaches = map;\n\t\t\t}\n\t\t}\n\n\t\t// We use an arbitrary (but consistent) object as key for the last item\n\t\t// in the WeakMap to serve as our running cache.\n\t\tif (!caches.has(LEAF_KEY)) {\n\t\t\tcache = createCache();\n\t\t\tcache.isUniqueByDependants = isUniqueByDependants;\n\t\t\tcaches.set(LEAF_KEY, cache);\n\t\t}\n\n\t\treturn caches.get(LEAF_KEY);\n\t}\n\n\t/**\n\t * Resets root memoization cache.\n\t */\n\tfunction clear() {\n\t\trootCache = new WeakMap();\n\t}\n\n\t/* eslint-disable jsdoc/check-param-names */\n\t/**\n\t * The augmented selector call, considering first whether dependants have\n\t * changed before passing it to underlying memoize function.\n\t *\n\t * @param {*}    source    Source object for derivation.\n\t * @param {...*} extraArgs Additional arguments to pass to selector.\n\t *\n\t * @return {*} Selector result.\n\t */\n\t/* eslint-enable jsdoc/check-param-names */\n\tfunction callSelector(/* source, ...extraArgs */) {\n\t\tvar len = arguments.length,\n\t\t\tcache,\n\t\t\tnode,\n\t\t\ti,\n\t\t\targs,\n\t\t\tdependants;\n\n\t\t// Create copy of arguments (avoid leaking deoptimization).\n\t\targs = new Array(len);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\tdependants = normalizedGetDependants.apply(null, args);\n\t\tcache = getCache(dependants);\n\n\t\t// If not guaranteed uniqueness by dependants (primitive type), shallow\n\t\t// compare against last dependants and, if references have changed,\n\t\t// destroy cache to recalculate result.\n\t\tif (!cache.isUniqueByDependants) {\n\t\t\tif (\n\t\t\t\tcache.lastDependants &&\n\t\t\t\t!isShallowEqual(dependants, cache.lastDependants, 0)\n\t\t\t) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\n\t\t\tcache.lastDependants = dependants;\n\t\t}\n\n\t\tnode = cache.head;\n\t\twhile (node) {\n\t\t\t// Check whether node arguments match arguments\n\t\t\tif (!isShallowEqual(node.args, args, 1)) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point we can assume we've found a match\n\n\t\t\t// Surface matched node to head if not already\n\t\t\tif (node !== cache.head) {\n\t\t\t\t// Adjust siblings to point to each other.\n\t\t\t\t/** @type {CacheNode} */ (node.prev).next = node.next;\n\t\t\t\tif (node.next) {\n\t\t\t\t\tnode.next.prev = node.prev;\n\t\t\t\t}\n\n\t\t\t\tnode.next = cache.head;\n\t\t\t\tnode.prev = null;\n\t\t\t\t/** @type {CacheNode} */ (cache.head).prev = node;\n\t\t\t\tcache.head = node;\n\t\t\t}\n\n\t\t\t// Return immediately\n\t\t\treturn node.val;\n\t\t}\n\n\t\t// No cached value found. Continue to insertion phase:\n\n\t\tnode = /** @type {CacheNode} */ ({\n\t\t\t// Generate the result from original function\n\t\t\tval: selector.apply(null, args),\n\t\t});\n\n\t\t// Avoid including the source object in the cache.\n\t\targs[0] = null;\n\t\tnode.args = args;\n\n\t\t// Don't need to check whether node is already head, since it would\n\t\t// have been returned above already if it was\n\n\t\t// Shift existing head down list\n\t\tif (cache.head) {\n\t\t\tcache.head.prev = node;\n\t\t\tnode.next = cache.head;\n\t\t}\n\n\t\tcache.head = node;\n\n\t\treturn node.val;\n\t}\n\n\tcallSelector.getDependants = normalizedGetDependants;\n\tcallSelector.clear = clear;\n\tclear();\n\n\treturn /** @type {S & EnhancedSelector} */ (callSelector);\n}\n","/**\n * External dependencies\n */\nimport createSelector from 'rememo';\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypes } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const availableFormats = getFormatTypes();\n *\n *    return availableFormats ? (\n *        <ul>\n *            { availableFormats?.map( ( format ) => (\n *                <li>{ format.name }</li>\n *           ) ) }\n *        </ul>\n *    ) : (\n *        __( 'No Formats available' )\n *    );\n * };\n * ```\n *\n * @return {Array} Format types.\n */\nexport const getFormatTypes = createSelector(\n\t( state ) => Object.values( state.formatTypes ),\n\t( state ) => [ state.formatTypes ]\n);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name  Format type name.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatType } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const boldFormat = getFormatType( 'core/bold' );\n *\n *    return boldFormat ? (\n *        <ul>\n *            { Object.entries( boldFormat )?.map( ( [ key, value ] ) => (\n *                <li>\n *                    { key } : { value }\n *                </li>\n *           ) ) }\n *       </ul>\n *    ) : (\n *        __( 'Not Found' )\n *    ;\n * };\n * ```\n *\n * @return {Object?} Format type.\n */\nexport function getFormatType( state, name ) {\n\treturn state.formatTypes[ name ];\n}\n\n/**\n * Gets the format type, if any, that can handle a bare element (without a\n * data-format-type attribute), given the tag name of this element.\n *\n * @param {Object} state              Data state.\n * @param {string} bareElementTagName The tag name of the element to find a\n *                                    format type for.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypeForBareElement } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const format = getFormatTypeForBareElement( 'strong' );\n *\n *    return format && <p>{ sprintf( __( 'Format name: %s' ), format.name ) }</p>;\n * }\n * ```\n *\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForBareElement( state, bareElementTagName ) {\n\tconst formatTypes = getFormatTypes( state );\n\treturn (\n\t\tformatTypes.find( ( { className, tagName } ) => {\n\t\t\treturn className === null && bareElementTagName === tagName;\n\t\t} ) ||\n\t\tformatTypes.find( ( { className, tagName } ) => {\n\t\t\treturn className === null && '*' === tagName;\n\t\t} )\n\t);\n}\n\n/**\n * Gets the format type, if any, that can handle an element, given its classes.\n *\n * @param {Object} state            Data state.\n * @param {string} elementClassName The classes of the element to find a format\n *                                  type for.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypeForClassName } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const format = getFormatTypeForClassName( 'has-inline-color' );\n *\n *    return format && <p>{ sprintf( __( 'Format name: %s' ), format.name ) }</p>;\n * };\n * ```\n *\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForClassName( state, elementClassName ) {\n\treturn getFormatTypes( state ).find( ( { className } ) => {\n\t\tif ( className === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ` ${ elementClassName } `.indexOf( ` ${ className } ` ) >= 0;\n\t} );\n}\n","/**\n * Returns an action object used in signalling that format types have been\n * added.\n * Ignored from documentation as registerFormatType should be used instead from @wordpress/rich-text\n *\n * @ignore\n *\n * @param {Array|Object} formatTypes Format types received.\n *\n * @return {Object} Action object.\n */\nexport function addFormatTypes( formatTypes ) {\n\treturn {\n\t\ttype: 'ADD_FORMAT_TYPES',\n\t\tformatTypes: Array.isArray( formatTypes )\n\t\t\t? formatTypes\n\t\t\t: [ formatTypes ],\n\t};\n}\n\n/**\n * Returns an action object used to remove a registered format type.\n *\n * Ignored from documentation as unregisterFormatType should be used instead from @wordpress/rich-text\n *\n * @ignore\n *\n * @param {string|Array} names Format name.\n *\n * @return {Object} Action object.\n */\nexport function removeFormatTypes( names ) {\n\treturn {\n\t\ttype: 'REMOVE_FORMAT_TYPES',\n\t\tnames: Array.isArray( names ) ? names : [ names ],\n\t};\n}\n","/**\n * WordPress dependencies\n */\nimport { createReduxStore, register } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as actions from './actions';\n\nconst STORE_NAME = 'core/rich-text';\n\n/**\n * Store definition for the rich-text namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n *\n * @type {Object}\n */\nexport const store = createReduxStore( STORE_NAME, {\n\treducer,\n\tselectors,\n\tactions,\n} );\n\nregister( store );\n","/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Optimised equality check for format objects.\n *\n * @param {?RichTextFormat} format1 Format to compare.\n * @param {?RichTextFormat} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nexport function isFormatEqual( format1, format2 ) {\n\t// Both not defined.\n\tif ( format1 === format2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! format1 || ! format2 ) {\n\t\treturn false;\n\t}\n\n\tif ( format1.type !== format2.type ) {\n\t\treturn false;\n\t}\n\n\tconst attributes1 = format1.attributes;\n\tconst attributes2 = format2.attributes;\n\n\t// Both not defined.\n\tif ( attributes1 === attributes2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! attributes1 || ! attributes2 ) {\n\t\treturn false;\n\t}\n\n\tconst keys1 = Object.keys( attributes1 );\n\tconst keys2 = Object.keys( attributes2 );\n\n\tif ( keys1.length !== keys2.length ) {\n\t\treturn false;\n\t}\n\n\tconst length = keys1.length;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst name = keys1[ i ];\n\n\t\tif ( attributes1[ name ] !== attributes2[ name ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Normalises formats: ensures subsequent adjacent equal formats have the same\n * reference.\n *\n * @param {RichTextValue} value Value to normalise formats of.\n *\n * @return {RichTextValue} New value with normalised formats.\n */\nexport function normaliseFormats( value ) {\n\tconst newFormats = value.formats.slice();\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst formatsAtPreviousIndex = newFormats[ index - 1 ];\n\n\t\tif ( formatsAtPreviousIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice();\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst previousFormat = formatsAtPreviousIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, previousFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = previousFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn {\n\t\t...value,\n\t\tformats: newFormats,\n\t};\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === format.type\n\t\t);\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ] &&\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ startIndex ] = replace(\n\t\t\t\t\tnewFormats[ startIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ] &&\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ endIndex ] = replace(\n\t\t\t\t\tnewFormats[ endIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\n\t\t\t\t\t( { type } ) => type !== format.type\n\t\t\t\t);\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...( activeFormats?.filter(\n\t\t\t\t( { type } ) => type !== format.type\n\t\t\t) || [] ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n","/**\n * Parse the given HTML into a body element.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createElement`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nexport function createElement( { implementation }, html ) {\n\t// Because `createHTMLDocument` is an expensive operation, and with this\n\t// function being internal to `rich-text` (full control in avoiding a risk\n\t// of asynchronous operations on the shared reference), a single document\n\t// is reused and reset for each call to the function.\n\tif ( ! createElement.body ) {\n\t\tcreateElement.body = implementation.createHTMLDocument( '' ).body;\n\t}\n\n\tcreateElement.body.innerHTML = html;\n\n\treturn createElement.body;\n}\n","/**\n * Object replacement character, used as a placeholder for objects.\n */\nexport const OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\n\n/**\n * Zero width non-breaking space, used as padding in the editable DOM tree when\n * it is empty otherwise.\n */\nexport const ZWNBSP = '\\ufeff';\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"escapeHtml\"];","/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormatList} RichTextFormatList */\n\n/**\n * Internal dependencies\n */\nimport { isFormatEqual } from './is-format-equal';\n\n/**\n * Gets the all format objects at the start of the selection.\n *\n * @param {RichTextValue} value                Value to inspect.\n * @param {Array}         EMPTY_ACTIVE_FORMATS Array to return if there are no\n *                                             active formats.\n *\n * @return {RichTextFormatList} Active format objects.\n */\nexport function getActiveFormats( value, EMPTY_ACTIVE_FORMATS = [] ) {\n\tconst { formats, start, end, activeFormats } = value;\n\tif ( start === undefined ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tif ( start === end ) {\n\t\t// For a collapsed caret, it is possible to override the active formats.\n\t\tif ( activeFormats ) {\n\t\t\treturn activeFormats;\n\t\t}\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\n\t\t// By default, select the lowest amount of formats possible (which means\n\t\t// the caret is positioned outside the format boundary). The user can\n\t\t// then use arrow keys to define `activeFormats`.\n\t\tif ( formatsBefore.length < formatsAfter.length ) {\n\t\t\treturn formatsBefore;\n\t\t}\n\n\t\treturn formatsAfter;\n\t}\n\n\t// If there's no formats at the start index, there are not active formats.\n\tif ( ! formats[ start ] ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tconst selectedFormats = formats.slice( start, end );\n\n\t// Clone the formats so we're not mutating the live value.\n\tconst _activeFormats = [ ...selectedFormats[ 0 ] ];\n\tlet i = selectedFormats.length;\n\n\t// For performance reasons, start from the end where it's much quicker to\n\t// realise that there are no active formats.\n\twhile ( i-- ) {\n\t\tconst formatsAtIndex = selectedFormats[ i ];\n\n\t\t// If we run into any index without formats, we're sure that there's no\n\t\t// active formats.\n\t\tif ( ! formatsAtIndex ) {\n\t\t\treturn EMPTY_ACTIVE_FORMATS;\n\t\t}\n\n\t\tlet ii = _activeFormats.length;\n\n\t\t// Loop over the active formats and remove any that are not present at\n\t\t// the current index.\n\t\twhile ( ii-- ) {\n\t\t\tconst format = _activeFormats[ ii ];\n\n\t\t\tif (\n\t\t\t\t! formatsAtIndex.find( ( _format ) =>\n\t\t\t\t\tisFormatEqual( format, _format )\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t_activeFormats.splice( ii, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// If there are no active formats, we can stop.\n\t\tif ( _activeFormats.length === 0 ) {\n\t\t\treturn EMPTY_ACTIVE_FORMATS;\n\t\t}\n\t}\n\n\treturn _activeFormats || EMPTY_ACTIVE_FORMATS;\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n\n/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */\n\n/**\n * Returns a registered format type.\n *\n * @param {string} name Format name.\n *\n * @return {RichTextFormatType|undefined} Format type.\n */\nexport function getFormatType( name ) {\n\treturn select( richTextStore ).getFormatType( name );\n}\n","/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\t// When a format is declared as non editable, make it non editable in the\n\t// editor.\n\tif ( isEditableTree && formatType.contentEditable === false ) {\n\t\telementAttributes.contenteditable = 'false';\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\tappend( tree, '' );\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tconst characterFormats = formats[ i ];\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree && format === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) continue;\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t\tboundaryClass: start === i && end === i + 1,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection and being editable.\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n","/**\n * WordPress dependencies\n */\n\nimport {\n\tescapeEditableHTML,\n\tescapeAttribute,\n\tisValidAttributeName,\n} from '@wordpress/escape-html';\n\n/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Create an HTML string from a Rich Text value.\n *\n * @param {Object}        $1                      Named argements.\n * @param {RichTextValue} $1.value                Rich text value.\n * @param {boolean}       [$1.preserveWhiteSpace] Preserves newlines if true.\n *\n * @return {string} HTML string.\n */\nexport function toHTMLString( { value, preserveWhiteSpace } ) {\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tpreserveWhiteSpace,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t} );\n\n\treturn createChildrenHTML( tree.children );\n}\n\nfunction createEmpty() {\n\treturn {};\n}\n\nfunction getLastChild( { children } ) {\n\treturn children && children[ children.length - 1 ];\n}\n\nfunction append( parent, object ) {\n\tif ( typeof object === 'string' ) {\n\t\tobject = { text: object };\n\t}\n\n\tobject.parent = parent;\n\tparent.children = parent.children || [];\n\tparent.children.push( object );\n\treturn object;\n}\n\nfunction appendText( object, text ) {\n\tobject.text += text;\n}\n\nfunction getParent( { parent } ) {\n\treturn parent;\n}\n\nfunction isText( { text } ) {\n\treturn typeof text === 'string';\n}\n\nfunction getText( { text } ) {\n\treturn text;\n}\n\nfunction remove( object ) {\n\tconst index = object.parent.children.indexOf( object );\n\n\tif ( index !== -1 ) {\n\t\tobject.parent.children.splice( index, 1 );\n\t}\n\n\treturn object;\n}\n\nfunction createElementHTML( { type, attributes, object, children } ) {\n\tlet attributeString = '';\n\n\tfor ( const key in attributes ) {\n\t\tif ( ! isValidAttributeName( key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tattributeString += ` ${ key }=\"${ escapeAttribute(\n\t\t\tattributes[ key ]\n\t\t) }\"`;\n\t}\n\n\tif ( object ) {\n\t\treturn `<${ type }${ attributeString }>`;\n\t}\n\n\treturn `<${ type }${ attributeString }>${ createChildrenHTML(\n\t\tchildren\n\t) }</${ type }>`;\n}\n\nfunction createChildrenHTML( children = [] ) {\n\treturn children\n\t\t.map( ( child ) => {\n\t\t\tif ( child.html !== undefined ) {\n\t\t\t\treturn child.html;\n\t\t\t}\n\n\t\t\treturn child.text === undefined\n\t\t\t\t? createElementHTML( child )\n\t\t\t\t: escapeEditableHTML( child.text );\n\t\t} )\n\t\t.join( '' );\n}\n","/**\n * Internal dependencies\n */\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {string} The text content.\n */\nexport function getTextContent( { text } ) {\n\treturn text.replace( OBJECT_REPLACEMENT_CHARACTER, '' );\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\nimport { createElement } from './create-element';\nimport { mergePair } from './concat';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\nimport { toHTMLString } from './to-html-string';\nimport { getTextContent } from './get-text-content';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\nfunction createEmptyValue() {\n\treturn {\n\t\tformats: [],\n\t\treplacements: [],\n\t\ttext: '',\n\t};\n}\n\nfunction toFormat( { tagName, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( richTextStore ).getFormatTypeForClassName(\n\t\t\tattributes.class\n\t\t);\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `\n\t\t\t\t.replace( ` ${ formatType.className } `, ' ' )\n\t\t\t\t.trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType =\n\t\t\tselect( richTextStore ).getFormatTypeForBareElement( tagName );\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type: tagName, attributes } : { type: tagName };\n\t}\n\n\tif (\n\t\tformatType.__experimentalCreatePrepareEditableTree &&\n\t\t! formatType.__experimentalCreateOnChangeEditableValue\n\t) {\n\t\treturn null;\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { formatType, type: formatType.name, tagName };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\tconst _attributes = { ...attributes };\n\n\tfor ( const key in formatType.attributes ) {\n\t\tconst name = formatType.attributes[ key ];\n\n\t\tregisteredAttributes[ key ] = _attributes[ name ];\n\n\t\t// delete the attribute and what's left is considered\n\t\t// to be unregistered.\n\t\tdelete _attributes[ name ];\n\n\t\tif ( typeof registeredAttributes[ key ] === 'undefined' ) {\n\t\t\tdelete registeredAttributes[ key ];\n\t\t}\n\t}\n\n\tfor ( const name in _attributes ) {\n\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t}\n\n\tif ( formatType.contentEditable === false ) {\n\t\tdelete unregisteredAttributes.contenteditable;\n\t}\n\n\treturn {\n\t\tformatType,\n\t\ttype: formatType.name,\n\t\ttagName,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * The RichTextData class is used to instantiate a wrapper around rich text\n * values, with methods that can be used to transform or manipulate the data.\n *\n * - Create an empty instance: `new RichTextData()`.\n * - Create one from an HTML string: `RichTextData.fromHTMLString(\n *   '<em>hello</em>' )`.\n * - Create one from a wrapper HTMLElement: `RichTextData.fromHTMLElement(\n *   document.querySelector( 'p' ) )`.\n * - Create one from plain text: `RichTextData.fromPlainText( '1\\n2' )`.\n * - Create one from a rich text value: `new RichTextData( { text: '...',\n *   formats: [ ... ] } )`.\n *\n * @todo Add methods to manipulate the data, such as applyFormat, slice etc.\n */\nexport class RichTextData {\n\t#value;\n\n\tstatic empty() {\n\t\treturn new RichTextData();\n\t}\n\tstatic fromPlainText( text ) {\n\t\treturn new RichTextData( create( { text } ) );\n\t}\n\tstatic fromHTMLString( html ) {\n\t\treturn new RichTextData( create( { html } ) );\n\t}\n\tstatic fromHTMLElement( htmlElement, options = {} ) {\n\t\tconst { preserveWhiteSpace = false } = options;\n\t\tconst element = preserveWhiteSpace\n\t\t\t? htmlElement\n\t\t\t: collapseWhiteSpace( htmlElement );\n\t\tconst richTextData = new RichTextData( create( { element } ) );\n\t\tObject.defineProperty( richTextData, 'originalHTML', {\n\t\t\tvalue: htmlElement.innerHTML,\n\t\t} );\n\t\treturn richTextData;\n\t}\n\tconstructor( init = createEmptyValue() ) {\n\t\tthis.#value = init;\n\t}\n\ttoPlainText() {\n\t\treturn getTextContent( this.#value );\n\t}\n\t// We could expose `toHTMLElement` at some point as well, but we'd only use\n\t// it internally.\n\ttoHTMLString( { preserveWhiteSpace } = {} ) {\n\t\treturn (\n\t\t\tthis.originalHTML ||\n\t\t\ttoHTMLString( { value: this.#value, preserveWhiteSpace } )\n\t\t);\n\t}\n\tvalueOf() {\n\t\treturn this.toHTMLString();\n\t}\n\ttoString() {\n\t\treturn this.toHTMLString();\n\t}\n\ttoJSON() {\n\t\treturn this.toHTMLString();\n\t}\n\tget length() {\n\t\treturn this.text.length;\n\t}\n\tget formats() {\n\t\treturn this.#value.formats;\n\t}\n\tget replacements() {\n\t\treturn this.#value.replacements;\n\t}\n\tget text() {\n\t\treturn this.#value.text;\n\t}\n}\n\nfor ( const name of Object.getOwnPropertyNames( String.prototype ) ) {\n\tif ( RichTextData.prototype.hasOwnProperty( name ) ) {\n\t\tcontinue;\n\t}\n\n\tObject.defineProperty( RichTextData.prototype, name, {\n\t\tvalue( ...args ) {\n\t\t\t// Should we convert back to RichTextData?\n\t\t\treturn this.toHTMLString()[ name ]( ...args );\n\t\t},\n\t} );\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. The optional\n * functions can be used to filter out content.\n *\n * A value will have the following shape, which you are strongly encouraged not\n * to modify without the use of helper functions:\n *\n * ```js\n * {\n *   text: string,\n *   formats: Array,\n *   replacements: Array,\n *   ?start: number,\n *   ?end: number,\n * }\n * ```\n *\n * As you can see, text and formatting are separated. `text` holds the text,\n * including any replacement characters for objects and lines. `formats`,\n * `objects` and `lines` are all sparse arrays of the same length as `text`. It\n * holds information about the formatting at the relevant text indices. Finally\n * `start` and `end` state which text indices are selected. They are only\n * provided if a `Range` was given.\n *\n * @param {Object}  [$1]                          Optional named arguments.\n * @param {Element} [$1.element]                  Element to create value from.\n * @param {string}  [$1.text]                     Text to create value from.\n * @param {string}  [$1.html]                     HTML to create value from.\n * @param {Range}   [$1.range]                    Range to create value from.\n * @param {boolean} [$1.__unstableIsEditableTree]\n * @return {RichTextValue} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\t__unstableIsEditableTree: isEditableTree,\n} = {} ) {\n\tif ( html instanceof RichTextData ) {\n\t\treturn {\n\t\t\ttext: html.text,\n\t\t\tformats: html.formats,\n\t\t\treplacements: html.replacements,\n\t\t};\n\t}\n\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\treplacements: Array( text.length ),\n\t\t\ttext,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\t// It does not matter which document this is, we're just using it to\n\t\t// parse.\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\treturn createFromElement( {\n\t\telement,\n\t\trange,\n\t\tisEditableTree,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {Object|void} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Collapse any whitespace used for HTML formatting to one space character,\n * because it will also be displayed as such by the browser.\n *\n * We need to strip it from the content because we use white-space: pre-wrap for\n * displaying editable rich text. Without using white-space: pre-wrap, the\n * browser will litter the content with non breaking spaces, among other issues.\n * See packages/rich-text/src/component/use-default-style.js.\n *\n * @see\n * https://developer.mozilla.org/en-US/docs/Web/CSS/white-space-collapse#collapsing_of_white_space\n *\n * @param {HTMLElement} element\n * @param {boolean}     isRoot\n *\n * @return {HTMLElement} New element with collapsed whitespace.\n */\nfunction collapseWhiteSpace( element, isRoot = true ) {\n\tconst clone = element.cloneNode( true );\n\tclone.normalize();\n\tArray.from( clone.childNodes ).forEach( ( node, i, nodes ) => {\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tlet newNodeValue = node.nodeValue;\n\n\t\t\tif ( /[\\n\\t\\r\\f]/.test( newNodeValue ) ) {\n\t\t\t\tnewNodeValue = newNodeValue.replace( /[\\n\\t\\r\\f]+/g, ' ' );\n\t\t\t}\n\n\t\t\tif ( newNodeValue.indexOf( '  ' ) !== -1 ) {\n\t\t\t\tnewNodeValue = newNodeValue.replace( / {2,}/g, ' ' );\n\t\t\t}\n\n\t\t\tif ( i === 0 && newNodeValue.startsWith( ' ' ) ) {\n\t\t\t\tnewNodeValue = newNodeValue.slice( 1 );\n\t\t\t} else if (\n\t\t\t\tisRoot &&\n\t\t\t\ti === nodes.length - 1 &&\n\t\t\t\tnewNodeValue.endsWith( ' ' )\n\t\t\t) {\n\t\t\t\tnewNodeValue = newNodeValue.slice( 0, -1 );\n\t\t\t}\n\n\t\t\tnode.nodeValue = newNodeValue;\n\t\t} else if ( node.nodeType === node.ELEMENT_NODE ) {\n\t\t\tcollapseWhiteSpace( node, false );\n\t\t}\n\t} );\n\treturn clone;\n}\n\n/**\n * We need to normalise line breaks to `\\n` so they are consistent across\n * platforms and serialised properly. Not removing \\r would cause it to\n * linger and result in double line breaks when whitespace is preserved.\n */\nconst CARRIAGE_RETURN = '\\r';\n\n/**\n * Removes reserved characters used by rich-text (zero width non breaking spaces\n * added by `toTree` and object replacement characters).\n *\n * @param {string} string\n */\nexport function removeReservedCharacters( string ) {\n\t// with the global flag, note that we should create a new regex each time OR\n\t// reset lastIndex state.\n\treturn string.replace(\n\t\tnew RegExp(\n\t\t\t`[${ ZWNBSP }${ OBJECT_REPLACEMENT_CHARACTER }${ CARRIAGE_RETURN }]`,\n\t\t\t'gu'\n\t\t),\n\t\t''\n\t);\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}  $1                  Named argements.\n * @param {Element} [$1.element]        Element to create value from.\n * @param {Range}   [$1.range]          Range to create value from.\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromElement( { element, range, isEditableTree } ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst tagName = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tconst text = removeReservedCharacters( node.nodeValue );\n\t\t\trange = filterRange( node, range, removeReservedCharacters );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\taccumulator.replacements.length += text.length;\n\t\t\taccumulator.text += text;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== node.ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tisEditableTree &&\n\t\t\t// Ignore any line breaks that are not inserted by us.\n\t\t\ttagName === 'br' &&\n\t\t\t! node.getAttribute( 'data-rich-text-line-break' )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'script' ) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: tagName,\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-script':\n\t\t\t\t\t\t\t\tnode.getAttribute( 'data-rich-text-script' ) ||\n\t\t\t\t\t\t\t\tencodeURIComponent( node.innerHTML ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, create( { text: '\\n' } ) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst format = toFormat( {\n\t\t\ttagName,\n\t\t\tattributes: getAttributes( { element: node } ),\n\t\t} );\n\n\t\t// When a format type is declared as not editable, replace it with an\n\t\t// object replacement character and preserve the inner HTML.\n\t\tif ( format?.formatType?.contentEditable === false ) {\n\t\t\tdelete format.formatType;\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\t...format,\n\t\t\t\t\t\tinnerHTML: node.innerHTML,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t} );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( format ) delete format.formatType;\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tisEditableTree,\n\t\t} );\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\t// Ignore any placeholders, but keep their content since the browser\n\t\t// might insert text inside them when the editable element is flex.\n\t\tif ( ! format || node.getAttribute( 'data-rich-text-placeholder' ) ) {\n\t\t\tmergePair( accumulator, value );\n\t\t} else if ( value.text.length === 0 ) {\n\t\t\tif ( format.attributes ) {\n\t\t\t\tmergePair( accumulator, {\n\t\t\t\t\tformats: [ , ],\n\t\t\t\t\treplacements: [ format ],\n\t\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\t// Indices should share a reference to the same formats array.\n\t\t\t// Only create a new reference if `formats` changes.\n\t\t\tfunction mergeFormats( formats ) {\n\t\t\t\tif ( mergeFormats.formats === formats ) {\n\t\t\t\t\treturn mergeFormats.newFormats;\n\t\t\t\t}\n\n\t\t\t\tconst newFormats = formats\n\t\t\t\t\t? [ format, ...formats ]\n\t\t\t\t\t: [ format ];\n\n\t\t\t\tmergeFormats.formats = formats;\n\t\t\t\tmergeFormats.newFormats = newFormats;\n\n\t\t\t\treturn newFormats;\n\t\t\t}\n\n\t\t\t// Since the formats parameter can be `undefined`, preset\n\t\t\t// `mergeFormats` with a new reference.\n\t\t\tmergeFormats.newFormats = [ format ];\n\n\t\t\tmergePair( accumulator, {\n\t\t\t\t...value,\n\t\t\t\tformats: Array.from( value.formats, mergeFormats ),\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}  $1         Named argements.\n * @param {Element} $1.element Element to get attributes from.\n *\n * @return {Object|void} Attribute object or `undefined` if the element has no\n *                       attributes.\n */\nfunction getAttributes( { element } ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( name.indexOf( 'data-rich-text-' ) === 0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst safeName = /^on/i.test( name )\n\t\t\t? 'data-disable-rich-text-' + name\n\t\t\t: name;\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ safeName ] = value;\n\t}\n\n\treturn accumulator;\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\nimport { create } from './create';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Concats a pair of rich text values. Not that this mutates `a` and does NOT\n * normalise formats!\n *\n * @param {Object} a Value to mutate.\n * @param {Object} b Value to add read from.\n *\n * @return {Object} `a`, mutated.\n */\nexport function mergePair( a, b ) {\n\ta.formats = a.formats.concat( b.formats );\n\ta.replacements = a.replacements.concat( b.replacements );\n\ta.text += b.text;\n\n\treturn a;\n}\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...RichTextValue} values Objects to combine.\n *\n * @return {RichTextValue} A new value combining all given records.\n */\nexport function concat( ...values ) {\n\treturn normaliseFormats( values.reduce( mergePair, create() ) );\n}\n","/**\n * Internal dependencies\n */\nimport { getActiveFormats } from './get-active-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {RichTextValue} value      Value to inspect.\n * @param {string}        formatType Format type to look for.\n *\n * @return {RichTextFormat|undefined} Active format object of the specified\n *                                    type, or undefined.\n */\nexport function getActiveFormat( value, formatType ) {\n\treturn getActiveFormats( value ).find(\n\t\t( { type } ) => type === formatType\n\t);\n}\n","/**\n * Internal dependencies\n */\n\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the active object, if there is any.\n *\n * @param {RichTextValue} value Value to inspect.\n *\n * @return {RichTextFormat|void} Active object, or undefined.\n */\nexport function getActiveObject( { start, end, replacements, text } ) {\n\tif ( start + 1 !== end || text[ start ] !== OBJECT_REPLACEMENT_CHARACTER ) {\n\t\treturn;\n\t}\n\n\treturn replacements[ start ];\n}\n","/**\n * Internal dependencies\n */\nimport type { RichTextValue } from './types';\n\n/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param props       The rich text value to check.\n * @param props.start\n * @param props.end\n * @return True if the selection is collapsed, false if not, undefined if there is no selection.\n */\nexport function isCollapsed( {\n\tstart,\n\tend,\n}: RichTextValue ): boolean | undefined {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\treturn start === end;\n}\n","/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nexport function isEmpty( { text } ) {\n\treturn text.length === 0;\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array<RichTextValue>} values      An array of values to join.\n * @param {string|RichTextValue} [separator] Separator string or value.\n *\n * @return {RichTextValue} A new combined value.\n */\nexport function join( values, separator = '' ) {\n\tif ( typeof separator === 'string' ) {\n\t\tseparator = create( { text: separator } );\n\t}\n\n\treturn normaliseFormats(\n\t\tvalues.reduce( ( accumlator, { formats, replacements, text } ) => ( {\n\t\t\tformats: accumlator.formats.concat( separator.formats, formats ),\n\t\t\treplacements: accumlator.replacements.concat(\n\t\t\t\tseparator.replacements,\n\t\t\t\treplacements\n\t\t\t),\n\t\t\ttext: accumlator.text + separator.text + text,\n\t\t} ) )\n\t);\n}\n","/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n/**\n * @typedef {Object} WPFormat\n *\n * @property {string}        name        A string identifying the format. Must be\n *                                       unique across all registered formats.\n * @property {string}        tagName     The HTML tag this format will wrap the\n *                                       selection with.\n * @property {boolean}       interactive Whether format makes content interactive or not.\n * @property {string | null} [className] A class to match the format.\n * @property {string}        title       Name of the format.\n * @property {Function}      edit        Should return a component for the user to\n *                                       interact with the new registered format.\n */\n\n/**\n * Registers a new format provided a unique name and an object defining its\n * behavior.\n *\n * @param {string}   name     Format name.\n * @param {WPFormat} settings Format settings.\n *\n * @return {WPFormat|undefined} The format, if it has been successfully\n *                              registered; otherwise `undefined`.\n */\nexport function registerFormatType( name, settings ) {\n\tsettings = {\n\t\tname,\n\t\t...settings,\n\t};\n\n\tif ( typeof settings.name !== 'string' ) {\n\t\twindow.console.error( 'Format names must be strings.' );\n\t\treturn;\n\t}\n\n\tif ( ! /^[a-z][a-z0-9-]*\\/[a-z][a-z0-9-]*$/.test( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( select( richTextStore ).getFormatType( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format \"' + settings.name + '\" is already registered.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.tagName !== 'string' || settings.tagName === '' ) {\n\t\twindow.console.error( 'Format tag names must be a string.' );\n\t\treturn;\n\t}\n\n\tif (\n\t\t( typeof settings.className !== 'string' ||\n\t\t\tsettings.className === '' ) &&\n\t\tsettings.className !== null\n\t) {\n\t\twindow.console.error(\n\t\t\t'Format class names must be a string, or null to handle bare elements.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! /^[_a-zA-Z]+[a-zA-Z0-9_-]*$/.test( settings.className ) ) {\n\t\twindow.console.error(\n\t\t\t'A class name must begin with a letter, followed by any number of hyphens, underscores, letters, or numbers.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( settings.className === null ) {\n\t\tconst formatTypeForBareElement = select(\n\t\t\trichTextStore\n\t\t).getFormatTypeForBareElement( settings.tagName );\n\n\t\tif (\n\t\t\tformatTypeForBareElement &&\n\t\t\tformatTypeForBareElement.name !== 'core/unknown'\n\t\t) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForBareElement.name }\" is already registered to handle bare tag name \"${ settings.tagName }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tconst formatTypeForClassName = select(\n\t\t\trichTextStore\n\t\t).getFormatTypeForClassName( settings.className );\n\n\t\tif ( formatTypeForClassName ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForClassName.name }\" is already registered to handle class name \"${ settings.className }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( ! ( 'title' in settings ) || settings.title === '' ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" must have a title.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( 'keywords' in settings && settings.keywords.length > 3 ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' +\n\t\t\t\tsettings.name +\n\t\t\t\t'\" can have a maximum of 3 keywords.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.title !== 'string' ) {\n\t\twindow.console.error( 'Format titles must be strings.' );\n\t\treturn;\n\t}\n\n\tdispatch( richTextStore ).addFormatTypes( settings );\n\n\treturn settings;\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {string}        formatType   Format type to remove.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function removeFormat(\n\tvalue,\n\tformatType,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === formatType\n\t\t);\n\n\t\tif ( format ) {\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ]?.find(\n\t\t\t\t\t( newFormat ) => newFormat === format\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ]?.find(\n\t\t\t\t\t( newFormat ) => newFormat === format\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\tactiveFormats:\n\t\t\tactiveFormats?.filter( ( { type } ) => type !== formatType ) || [],\n\t} );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter(\n\t\t( { type } ) => type !== formatType\n\t);\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {RichTextValue}        value         Value to modify.\n * @param {RichTextValue|string} valueToInsert Value to insert.\n * @param {number}               [startIndex]  Start index.\n * @param {number}               [endIndex]    End index.\n *\n * @return {RichTextValue} A new value with the value inserted.\n */\nexport function insert(\n\tvalue,\n\tvalueToInsert,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( typeof valueToInsert === 'string' ) {\n\t\tvalueToInsert = create( { text: valueToInsert } );\n\t}\n\n\tconst index = startIndex + valueToInsert.text.length;\n\n\treturn normaliseFormats( {\n\t\tformats: formats\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat( valueToInsert.formats, formats.slice( endIndex ) ),\n\t\treplacements: replacements\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat(\n\t\t\t\tvalueToInsert.replacements,\n\t\t\t\treplacements.slice( endIndex )\n\t\t\t),\n\t\ttext:\n\t\t\ttext.slice( 0, startIndex ) +\n\t\t\tvalueToInsert.text +\n\t\t\ttext.slice( endIndex ),\n\t\tstart: index,\n\t\tend: index,\n\t} );\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { create } from './create';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the content removed.\n */\nexport function remove( value, startIndex, endIndex ) {\n\treturn insert( value, create(), startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {RichTextValue}   value       The value to modify.\n * @param {RegExp|string}   pattern     A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {RichTextValue} A new value with replacements applied.\n */\nexport function replace(\n\t{ formats, replacements, text, start, end },\n\tpattern,\n\treplacement\n) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\t\tlet newReplacements;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewReplacements = newText.replacements;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\t\t\tnewReplacements = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats\n\t\t\t.slice( 0, offset )\n\t\t\t.concat( newFormats, formats.slice( offset + match.length ) );\n\t\treplacements = replacements\n\t\t\t.slice( 0, offset )\n\t\t\t.concat(\n\t\t\t\tnewReplacements,\n\t\t\t\treplacements.slice( offset + match.length )\n\t\t\t);\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, replacements, text, start, end } );\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Insert a format as an object into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue}  value          Value to modify.\n * @param {RichTextFormat} formatToInsert Format to insert as object.\n * @param {number}         [startIndex]   Start index.\n * @param {number}         [endIndex]     End index.\n *\n * @return {RichTextValue} A new value with the object inserted.\n */\nexport function insertObject( value, formatToInsert, startIndex, endIndex ) {\n\tconst valueToInsert = {\n\t\tformats: [ , ],\n\t\treplacements: [ formatToInsert ],\n\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n","/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new extracted value.\n */\nexport function slice( value, startIndex = value.start, endIndex = value.end ) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( startIndex === undefined || endIndex === undefined ) {\n\t\treturn { ...value };\n\t}\n\n\treturn {\n\t\tformats: formats.slice( startIndex, endIndex ),\n\t\treplacements: replacements.slice( startIndex, endIndex ),\n\t\ttext: text.slice( startIndex, endIndex ),\n\t};\n}\n","/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>|undefined} An array of new values.\n */\nexport function split( { formats, replacements, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\treplacements: replacements.slice(\n\t\t\t\tstartIndex,\n\t\t\t\tstartIndex + substring.length\n\t\t\t),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, replacements, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\treplacements: replacements.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\treplacements: replacements.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [ before, after ];\n}\n","/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range|null} a First range object to test.\n * @param {Range|null} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nexport function isRangeEqual( a, b ) {\n\treturn (\n\t\ta === b ||\n\t\t( a &&\n\t\t\tb &&\n\t\t\ta.startContainer === b.startContainer &&\n\t\t\ta.startOffset === b.startOffset &&\n\t\t\ta.endContainer === b.endContainer &&\n\t\t\ta.endOffset === b.endOffset )\n\t);\n}\n","/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\nimport { isRangeEqual } from './is-range-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction append( element, child ) {\n\tif ( child.html !== undefined ) {\n\t\treturn ( element.innerHTML += child.html );\n\t}\n\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( node ) {\n\treturn node.nodeType === node.TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tprepareEditableTree,\n\tisEditableTree = true,\n\tplaceholder,\n\tdoc = document,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new instance of a DOM tree upon which RichText operations can be\n\t * applied.\n\t *\n\t * Note: The current implementation will return a shared reference, reset on\n\t * each call to `createEmpty`. Therefore, you should not hold a reference to\n\t * the value to operate upon asynchronously, as it may have unexpected results.\n\t *\n\t * @return {Object} RichText tree.\n\t */\n\tconst createEmpty = () => createElement( doc, '' );\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tisEditableTree,\n\t\tplaceholder,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`.\n *\n * @param {Object}        $1                       Named arguments.\n * @param {RichTextValue} $1.value                 Value to apply.\n * @param {HTMLElement}   $1.current               The live root node to apply the element tree to.\n * @param {Function}      [$1.prepareEditableTree] Function to filter editorable formats.\n * @param {boolean}       [$1.__unstableDomOnly]   Only apply elements, no selection.\n * @param {string}        [$1.placeholder]         Placeholder text.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n\tplaceholder,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tprepareEditableTree,\n\t\tplaceholder,\n\t\tdoc: current.ownerDocument,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === currentChild.TEXT_NODE &&\n\t\t\t\t\tcurrentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tstartPath\n\t);\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tendPath\n\t);\n\tconst { ownerDocument } = current;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tconst { activeElement } = ownerDocument;\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n\n\t// This function is not intended to cause a shift in focus. Since the above\n\t// selection manipulations may shift focus, ensure that focus is restored to\n\t// its previous state.\n\tif ( activeElement !== ownerDocument.activeElement ) {\n\t\t// The `instanceof` checks protect against edge cases where the focused\n\t\t// element is not of the interface HTMLElement (does not have a `focus`\n\t\t// or `blur` property).\n\t\t//\n\t\t// See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n\t\tif ( activeElement instanceof defaultView.HTMLElement ) {\n\t\t\tactiveElement.focus();\n\t\t}\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"a11y\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"i18n\"];","/**\n * WordPress dependencies\n */\n\nimport { speak } from '@wordpress/a11y';\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\n\nimport { getActiveFormat } from './get-active-format';\nimport { removeFormat } from './remove-format';\nimport { applyFormat } from './apply-format';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Toggles a format object to a Rich Text value at the current selection.\n *\n * @param {RichTextValue}  value  Value to modify.\n * @param {RichTextFormat} format Format to apply or remove.\n *\n * @return {RichTextValue} A new value with the format applied or removed.\n */\nexport function toggleFormat( value, format ) {\n\tif ( getActiveFormat( value, format.type ) ) {\n\t\t// For screen readers, will announce if formatting control is disabled.\n\t\tif ( format.title ) {\n\t\t\t// translators: %s: title of the formatting control\n\t\t\tspeak( sprintf( __( '%s removed.' ), format.title ), 'assertive' );\n\t\t}\n\t\treturn removeFormat( value, format.type );\n\t}\n\t// For screen readers, will announce if formatting control is enabled.\n\tif ( format.title ) {\n\t\t// translators: %s: title of the formatting control\n\t\tspeak( sprintf( __( '%s applied.' ), format.title ), 'assertive' );\n\t}\n\treturn applyFormat( value, format );\n}\n","/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n\n/** @typedef {import('./register-format-type').WPFormat} WPFormat */\n\n/**\n * Unregisters a format.\n *\n * @param {string} name Format name.\n *\n * @return {WPFormat|undefined} The previous format value, if it has\n *                                        been successfully unregistered;\n *                                        otherwise `undefined`.\n */\nexport function unregisterFormatType( name ) {\n\tconst oldFormat = select( richTextStore ).getFormatType( name );\n\n\tif ( ! oldFormat ) {\n\t\twindow.console.error( `Format ${ name } is not registered.` );\n\t\treturn;\n\t}\n\n\tdispatch( richTextStore ).removeFormatTypes( name );\n\n\treturn oldFormat;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"element\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"deprecated\"];","/**\n * WordPress dependencies\n */\nimport { useMemo } from '@wordpress/element';\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Internal dependencies\n */\nimport { getActiveFormat } from '../get-active-format';\n\n/**\n * @template T\n * @typedef {import('@wordpress/element').RefObject<T>} RefObject<T>\n */\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or the selection range if no format is active.\n * The returned value is meant to be used for positioning UI, e.g. by passing it\n * to the `Popover` component.\n *\n * @param {Object}                 $1          Named parameters.\n * @param {RefObject<HTMLElement>} $1.ref      React ref of the element\n *                                             containing  the editable content.\n * @param {RichTextValue}          $1.value    Value to check for selection.\n * @param {WPFormat}               $1.settings The format type's settings.\n *\n * @return {Element|Range} The active element or selection range.\n */\nexport function useAnchorRef( { ref, value, settings = {} } ) {\n\tdeprecated( '`useAnchorRef` hook', {\n\t\tsince: '6.1',\n\t\talternative: '`useAnchor` hook',\n\t} );\n\n\tconst { tagName, className, name } = settings;\n\tconst activeFormat = name ? getActiveFormat( value, name ) : undefined;\n\n\treturn useMemo( () => {\n\t\tif ( ! ref.current ) return;\n\t\tconst {\n\t\t\townerDocument: { defaultView },\n\t\t} = ref.current;\n\t\tconst selection = defaultView.getSelection();\n\n\t\tif ( ! selection.rangeCount ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst range = selection.getRangeAt( 0 );\n\n\t\tif ( ! activeFormat ) {\n\t\t\treturn range;\n\t\t}\n\n\t\tlet element = range.startContainer;\n\n\t\t// If the caret is right before the element, select the next element.\n\t\telement = element.nextElementSibling || element;\n\n\t\twhile ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\t\telement = element.parentNode;\n\t\t}\n\n\t\treturn element.closest(\n\t\t\ttagName + ( className ? '.' + className : '' )\n\t\t);\n\t}, [ activeFormat, value.start, value.end, tagName, className ] );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"compose\"];","/**\n * WordPress dependencies\n */\nimport { usePrevious } from '@wordpress/compose';\nimport { useState, useLayoutEffect } from '@wordpress/element';\n\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * Given a range and a format tag name and class name, returns the closest\n * format element.\n *\n * @param {Range}       range                  The Range to check.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format element.\n * @param {string}      className              The class name of the format element.\n *\n * @return {HTMLElement|undefined} The format element, if found.\n */\nfunction getFormatElement( range, editableContentElement, tagName, className ) {\n\tlet element = range.startContainer;\n\n\t// Even if the active format is defined, the actualy DOM range's start\n\t// container may be outside of the format's DOM element:\n\t// `a‸<strong>b</strong>` (DOM) while visually it's `a<strong>‸b</strong>`.\n\t// So at a given selection index, start with the deepest format DOM element.\n\tif (\n\t\telement.nodeType === element.TEXT_NODE &&\n\t\trange.startOffset === element.length &&\n\t\telement.nextSibling\n\t) {\n\t\telement = element.nextSibling;\n\n\t\twhile ( element.firstChild ) {\n\t\t\telement = element.firstChild;\n\t\t}\n\t}\n\n\tif ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\telement = element.parentElement;\n\t}\n\n\tif ( ! element ) return;\n\tif ( element === editableContentElement ) return;\n\tif ( ! editableContentElement.contains( element ) ) return;\n\n\tconst selector = tagName + ( className ? '.' + className : '' );\n\n\t// .closest( selector ), but with a boundary. Check if the element matches\n\t// the selector. If it doesn't match, try the parent element if it's not the\n\t// editable wrapper. We don't want to try to match ancestors of the editable\n\t// wrapper, which is what .closest( selector ) would do. When the element is\n\t// the editable wrapper (which is most likely the case because most text is\n\t// unformatted), this never runs.\n\twhile ( element !== editableContentElement ) {\n\t\tif ( element.matches( selector ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\telement = element.parentElement;\n\t}\n}\n\n/**\n * @typedef {Object} VirtualAnchorElement\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\n * @property {HTMLElement}   contextElement        The actual DOM element\n */\n\n/**\n * Creates a virtual anchor element for a range.\n *\n * @param {Range}       range                  The range to create a virtual anchor element for.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n *\n * @return {VirtualAnchorElement} The virtual anchor element.\n */\nfunction createVirtualAnchorElement( range, editableContentElement ) {\n\treturn {\n\t\tcontextElement: editableContentElement,\n\t\tgetBoundingClientRect() {\n\t\t\treturn editableContentElement.contains( range.startContainer )\n\t\t\t\t? range.getBoundingClientRect()\n\t\t\t\t: editableContentElement.getBoundingClientRect();\n\t\t},\n\t};\n}\n\n/**\n * Get the anchor: a format element if there is a matching one based on the\n * tagName and className or a range otherwise.\n *\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format\n *                                             element.\n * @param {string}      className              The class name of the format\n *                                             element.\n *\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\n */\nfunction getAnchor( editableContentElement, tagName, className ) {\n\tif ( ! editableContentElement ) return;\n\n\tconst { ownerDocument } = editableContentElement;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection ) return;\n\tif ( ! selection.rangeCount ) return;\n\n\tconst range = selection.getRangeAt( 0 );\n\n\tif ( ! range || ! range.startContainer ) return;\n\n\tconst formatElement = getFormatElement(\n\t\trange,\n\t\teditableContentElement,\n\t\ttagName,\n\t\tclassName\n\t);\n\n\tif ( formatElement ) return formatElement;\n\n\treturn createVirtualAnchorElement( range, editableContentElement );\n}\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or a virtual element for the selection range if\n * no format is active. The returned value is meant to be used for positioning\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\n *\n * @param {Object}           $1                        Named parameters.\n * @param {HTMLElement|null} $1.editableContentElement The element containing\n *                                                     the editable content.\n * @param {WPFormat=}        $1.settings               The format type's settings.\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\n */\nexport function useAnchor( { editableContentElement, settings = {} } ) {\n\tconst { tagName, className, isActive } = settings;\n\tconst [ anchor, setAnchor ] = useState( () =>\n\t\tgetAnchor( editableContentElement, tagName, className )\n\t);\n\tconst wasActive = usePrevious( isActive );\n\n\tuseLayoutEffect( () => {\n\t\tif ( ! editableContentElement ) return;\n\n\t\tfunction callback() {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t}\n\n\t\tfunction attach() {\n\t\t\townerDocument.addEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tfunction detach() {\n\t\t\townerDocument.removeEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tconst { ownerDocument } = editableContentElement;\n\n\t\tif (\n\t\t\teditableContentElement === ownerDocument.activeElement ||\n\t\t\t// When a link is created, we need to attach the popover to the newly created anchor.\n\t\t\t( ! wasActive && isActive ) ||\n\t\t\t// Sometimes we're _removing_ an active anchor, such as the inline color popover.\n\t\t\t// When we add the color, it switches from a virtual anchor to a `<mark>` element.\n\t\t\t// When we _remove_ the color, it switches from a `<mark>` element to a virtual anchor.\n\t\t\t( wasActive && ! isActive )\n\t\t) {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t\tattach();\n\t\t}\n\n\t\teditableContentElement.addEventListener( 'focusin', attach );\n\t\teditableContentElement.addEventListener( 'focusout', detach );\n\n\t\treturn () => {\n\t\t\tdetach();\n\n\t\t\teditableContentElement.removeEventListener( 'focusin', attach );\n\t\t\teditableContentElement.removeEventListener( 'focusout', detach );\n\t\t};\n\t}, [ editableContentElement, tagName, className, isActive, wasActive ] );\n\n\treturn anchor;\n}\n","/**\n * WordPress dependencies\n */\nimport { useCallback } from '@wordpress/element';\n\n/**\n * In HTML, leading and trailing spaces are not visible, and multiple spaces\n * elsewhere are visually reduced to one space. This rule prevents spaces from\n * collapsing so all space is visible in the editor and can be removed. It also\n * prevents some browsers from inserting non-breaking spaces at the end of a\n * line to prevent the space from visually disappearing. Sometimes these non\n * breaking spaces can linger in the editor causing unwanted non breaking spaces\n * in between words. If also prevent Firefox from inserting a trailing `br` node\n * to visualise any trailing space, causing the element to be saved.\n *\n * > Authors are encouraged to set the 'white-space' property on editing hosts\n * > and on markup that was originally created through these editing mechanisms\n * > to the value 'pre-wrap'. Default HTML whitespace handling is not well\n * > suited to WYSIWYG editing, and line wrapping will not work correctly in\n * > some corner cases if 'white-space' is left at its default value.\n *\n * https://html.spec.whatwg.org/multipage/interaction.html#best-practices-for-in-page-editors\n *\n * @type {string}\n */\nconst whiteSpace = 'pre-wrap';\n\n/**\n * A minimum width of 1px will prevent the rich text container from collapsing\n * to 0 width and hiding the caret. This is useful for inline containers.\n */\nconst minWidth = '1px';\n\nexport function useDefaultStyle() {\n\treturn useCallback( ( element ) => {\n\t\tif ( ! element ) return;\n\t\telement.style.whiteSpace = whiteSpace;\n\t\telement.style.minWidth = minWidth;\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useEffect, useRef } from '@wordpress/element';\n\n/*\n * Calculates and renders the format boundary style when the active formats\n * change.\n */\nexport function useBoundaryStyle( { record } ) {\n\tconst ref = useRef();\n\tconst { activeFormats = [], replacements, start } = record.current;\n\tconst activeReplacement = replacements[ start ];\n\tuseEffect( () => {\n\t\t// There's no need to recalculate the boundary styles if no formats are\n\t\t// active, because no boundary styles will be visible.\n\t\tif (\n\t\t\t( ! activeFormats || ! activeFormats.length ) &&\n\t\t\t! activeReplacement\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst boundarySelector = '*[data-rich-text-format-boundary]';\n\t\tconst element = ref.current.querySelector( boundarySelector );\n\n\t\tif ( ! element ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\t\tconst computedStyle = defaultView.getComputedStyle( element );\n\t\tconst newColor = computedStyle.color\n\t\t\t.replace( ')', ', 0.2)' )\n\t\t\t.replace( 'rgb', 'rgba' );\n\t\tconst selector = `.rich-text:focus ${ boundarySelector }`;\n\t\tconst rule = `background-color: ${ newColor }`;\n\t\tconst style = `${ selector } {${ rule }}`;\n\t\tconst globalStyleId = 'rich-text-boundary-style';\n\n\t\tlet globalStyle = ownerDocument.getElementById( globalStyleId );\n\n\t\tif ( ! globalStyle ) {\n\t\t\tglobalStyle = ownerDocument.createElement( 'style' );\n\t\t\tglobalStyle.id = globalStyleId;\n\t\t\townerDocument.head.appendChild( globalStyle );\n\t\t}\n\n\t\tif ( globalStyle.innerHTML !== style ) {\n\t\t\tglobalStyle.innerHTML = style;\n\t\t}\n\t}, [ activeFormats, activeReplacement ] );\n\treturn ref;\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { toHTMLString } from '../to-html-string';\nimport { isCollapsed } from '../is-collapsed';\nimport { slice } from '../slice';\nimport { getTextContent } from '../get-text-content';\n\nexport function useCopyHandler( props ) {\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onCopy( event ) {\n\t\t\tconst { record } = propsRef.current;\n\t\t\tconst { ownerDocument } = element;\n\t\t\tif (\n\t\t\t\tisCollapsed( record.current ) ||\n\t\t\t\t! element.contains( ownerDocument.activeElement )\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedRecord = slice( record.current );\n\t\t\tconst plainText = getTextContent( selectedRecord );\n\t\t\tconst html = toHTMLString( { value: selectedRecord } );\n\t\t\tevent.clipboardData.setData( 'text/plain', plainText );\n\t\t\tevent.clipboardData.setData( 'text/html', html );\n\t\t\tevent.clipboardData.setData( 'rich-text', 'true' );\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( event.type === 'cut' ) {\n\t\t\t\townerDocument.execCommand( 'delete' );\n\t\t\t}\n\t\t}\n\n\t\telement.addEventListener( 'copy', onCopy );\n\t\telement.addEventListener( 'cut', onCopy );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'copy', onCopy );\n\t\t\telement.removeEventListener( 'cut', onCopy );\n\t\t};\n\t}, [] );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"keycodes\"];","/**\n * WordPress dependencies\n */\nimport { useRef, useReducer } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\nimport { LEFT, RIGHT } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { isCollapsed } from '../is-collapsed';\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\nexport function useFormatBoundaries( props ) {\n\tconst [ , forceRender ] = useReducer( () => ( {} ) );\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onKeyDown( event ) {\n\t\t\tconst { keyCode, shiftKey, altKey, metaKey, ctrlKey } = event;\n\n\t\t\tif (\n\t\t\t\t// Only override left and right keys without modifiers pressed.\n\t\t\t\tshiftKey ||\n\t\t\t\taltKey ||\n\t\t\t\tmetaKey ||\n\t\t\t\tctrlKey ||\n\t\t\t\t( keyCode !== LEFT && keyCode !== RIGHT )\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { record, applyRecord } = propsRef.current;\n\t\t\tconst {\n\t\t\t\ttext,\n\t\t\t\tformats,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tactiveFormats: currentActiveFormats = [],\n\t\t\t} = record.current;\n\t\t\tconst collapsed = isCollapsed( record.current );\n\t\t\tconst { ownerDocument } = element;\n\t\t\tconst { defaultView } = ownerDocument;\n\t\t\t// To do: ideally, we should look at visual position instead.\n\t\t\tconst { direction } = defaultView.getComputedStyle( element );\n\t\t\tconst reverseKey = direction === 'rtl' ? RIGHT : LEFT;\n\t\t\tconst isReverse = event.keyCode === reverseKey;\n\n\t\t\t// If the selection is collapsed and at the very start, do nothing if\n\t\t\t// navigating backward.\n\t\t\t// If the selection is collapsed and at the very end, do nothing if\n\t\t\t// navigating forward.\n\t\t\tif ( collapsed && currentActiveFormats.length === 0 ) {\n\t\t\t\tif ( start === 0 && isReverse ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( end === text.length && ! isReverse ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the selection is not collapsed, let the browser handle collapsing\n\t\t\t// the selection for now. Later we could expand this logic to set\n\t\t\t// boundary positions if needed.\n\t\t\tif ( ! collapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\t\t\tconst destination = isReverse ? formatsBefore : formatsAfter;\n\t\t\tconst isIncreasing = currentActiveFormats.every(\n\t\t\t\t( format, index ) => format === destination[ index ]\n\t\t\t);\n\n\t\t\tlet newActiveFormatsLength = currentActiveFormats.length;\n\n\t\t\tif ( ! isIncreasing ) {\n\t\t\t\tnewActiveFormatsLength--;\n\t\t\t} else if ( newActiveFormatsLength < destination.length ) {\n\t\t\t\tnewActiveFormatsLength++;\n\t\t\t}\n\n\t\t\tif ( newActiveFormatsLength === currentActiveFormats.length ) {\n\t\t\t\trecord.current._newActiveFormats = destination;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconst origin = isReverse ? formatsAfter : formatsBefore;\n\t\t\tconst source = isIncreasing ? destination : origin;\n\t\t\tconst newActiveFormats = source.slice( 0, newActiveFormatsLength );\n\t\t\tconst newValue = {\n\t\t\t\t...record.current,\n\t\t\t\tactiveFormats: newActiveFormats,\n\t\t\t};\n\t\t\trecord.current = newValue;\n\t\t\tapplyRecord( newValue );\n\t\t\tforceRender();\n\t\t}\n\n\t\telement.addEventListener( 'keydown', onKeyDown );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t\t};\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { getActiveFormats } from '../get-active-formats';\nimport { updateFormats } from '../update-formats';\n\n/**\n * All inserting input types that would insert HTML into the DOM.\n *\n * @see https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes\n *\n * @type {Set}\n */\nconst INSERTION_INPUT_TYPES_TO_IGNORE = new Set( [\n\t'insertParagraph',\n\t'insertOrderedList',\n\t'insertUnorderedList',\n\t'insertHorizontalRule',\n\t'insertLink',\n] );\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\nconst PLACEHOLDER_ATTR_NAME = 'data-rich-text-placeholder';\n\n/**\n * If the selection is set on the placeholder element, collapse the selection to\n * the start (before the placeholder).\n *\n * @param {Window} defaultView\n */\nfunction fixPlaceholderSelection( defaultView ) {\n\tconst selection = defaultView.getSelection();\n\tconst { anchorNode, anchorOffset } = selection;\n\n\tif ( anchorNode.nodeType !== anchorNode.ELEMENT_NODE ) {\n\t\treturn;\n\t}\n\n\tconst targetNode = anchorNode.childNodes[ anchorOffset ];\n\n\tif (\n\t\t! targetNode ||\n\t\ttargetNode.nodeType !== targetNode.ELEMENT_NODE ||\n\t\t! targetNode.hasAttribute( PLACEHOLDER_ATTR_NAME )\n\t) {\n\t\treturn;\n\t}\n\n\tselection.collapseToStart();\n}\n\nexport function useInputAndSelection( props ) {\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\n\t\tlet isComposing = false;\n\n\t\tfunction onInput( event ) {\n\t\t\t// Do not trigger a change if characters are being composed.\n\t\t\t// Browsers  will usually emit a final `input` event when the\n\t\t\t// characters are composed.\n\t\t\t// As of December 2019, Safari doesn't support\n\t\t\t// nativeEvent.isComposing.\n\t\t\tif ( isComposing ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet inputType;\n\n\t\t\tif ( event ) {\n\t\t\t\tinputType = event.inputType;\n\t\t\t}\n\n\t\t\tconst { record, applyRecord, createRecord, handleChange } =\n\t\t\t\tpropsRef.current;\n\n\t\t\t// The browser formatted something or tried to insert HTML.\n\t\t\t// Overwrite it. It will be handled later by the format library if\n\t\t\t// needed.\n\t\t\tif (\n\t\t\t\tinputType &&\n\t\t\t\t( inputType.indexOf( 'format' ) === 0 ||\n\t\t\t\t\tINSERTION_INPUT_TYPES_TO_IGNORE.has( inputType ) )\n\t\t\t) {\n\t\t\t\tapplyRecord( record.current );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentValue = createRecord();\n\t\t\tconst { start, activeFormats: oldActiveFormats = [] } =\n\t\t\t\trecord.current;\n\n\t\t\t// Update the formats between the last and new caret position.\n\t\t\tconst change = updateFormats( {\n\t\t\t\tvalue: currentValue,\n\t\t\t\tstart,\n\t\t\t\tend: currentValue.start,\n\t\t\t\tformats: oldActiveFormats,\n\t\t\t} );\n\n\t\t\thandleChange( change );\n\t\t}\n\n\t\t/**\n\t\t * Syncs the selection to local state. A callback for the\n\t\t * `selectionchange` event.\n\t\t */\n\t\tfunction handleSelectionChange() {\n\t\t\tconst { record, applyRecord, createRecord, onSelectionChange } =\n\t\t\t\tpropsRef.current;\n\n\t\t\t// Check if the implementor disabled editing. `contentEditable`\n\t\t\t// does disable input, but not text selection, so we must ignore\n\t\t\t// selection changes.\n\t\t\tif ( element.contentEditable !== 'true' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ensure the active element is the rich text element.\n\t\t\tif ( ownerDocument.activeElement !== element ) {\n\t\t\t\t// If it is not, we can stop listening for selection changes.\n\t\t\t\t// We resume listening when the element is focused.\n\t\t\t\townerDocument.removeEventListener(\n\t\t\t\t\t'selectionchange',\n\t\t\t\t\thandleSelectionChange\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case of a keyboard event, ignore selection changes during\n\t\t\t// composition.\n\t\t\tif ( isComposing ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { start, end, text } = createRecord();\n\t\t\tconst oldRecord = record.current;\n\n\t\t\t// Fallback mechanism for IE11, which doesn't support the input event.\n\t\t\t// Any input results in a selection change.\n\t\t\tif ( text !== oldRecord.text ) {\n\t\t\t\tonInput();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( start === oldRecord.start && end === oldRecord.end ) {\n\t\t\t\t// Sometimes the browser may set the selection on the placeholder\n\t\t\t\t// element, in which case the caret is not visible. We need to set\n\t\t\t\t// the caret before the placeholder if that's the case.\n\t\t\t\tif ( oldRecord.text.length === 0 && start === 0 ) {\n\t\t\t\t\tfixPlaceholderSelection( defaultView );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newValue = {\n\t\t\t\t...oldRecord,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\t// _newActiveFormats may be set on arrow key navigation to control\n\t\t\t\t// the right boundary position. If undefined, getActiveFormats will\n\t\t\t\t// give the active formats according to the browser.\n\t\t\t\tactiveFormats: oldRecord._newActiveFormats,\n\t\t\t\t_newActiveFormats: undefined,\n\t\t\t};\n\n\t\t\tconst newActiveFormats = getActiveFormats(\n\t\t\t\tnewValue,\n\t\t\t\tEMPTY_ACTIVE_FORMATS\n\t\t\t);\n\n\t\t\t// Update the value with the new active formats.\n\t\t\tnewValue.activeFormats = newActiveFormats;\n\n\t\t\t// It is important that the internal value is updated first,\n\t\t\t// otherwise the value will be wrong on render!\n\t\t\trecord.current = newValue;\n\t\t\tapplyRecord( newValue, { domOnly: true } );\n\t\t\tonSelectionChange( start, end );\n\t\t}\n\n\t\tfunction onCompositionStart() {\n\t\t\tisComposing = true;\n\t\t\t// Do not update the selection when characters are being composed as\n\t\t\t// this rerenders the component and might destroy internal browser\n\t\t\t// editing state.\n\t\t\townerDocument.removeEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t\t// Remove the placeholder. Since the rich text value doesn't update\n\t\t\t// during composition, the placeholder doesn't get removed. There's\n\t\t\t// no need to re-add it, when the value is updated on compositionend\n\t\t\t// it will be re-added when the value is empty.\n\t\t\telement.querySelector( `[${ PLACEHOLDER_ATTR_NAME }]` )?.remove();\n\t\t}\n\n\t\tfunction onCompositionEnd() {\n\t\t\tisComposing = false;\n\t\t\t// Ensure the value is up-to-date for browsers that don't emit a final\n\t\t\t// input event after composition.\n\t\t\tonInput( { inputType: 'insertText' } );\n\t\t\t// Tracking selection changes can be resumed.\n\t\t\townerDocument.addEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t}\n\n\t\tfunction onFocus() {\n\t\t\tconst { record, isSelected, onSelectionChange, applyRecord } =\n\t\t\t\tpropsRef.current;\n\n\t\t\t// When the whole editor is editable, let writing flow handle\n\t\t\t// selection.\n\t\t\tif ( element.parentElement.closest( '[contenteditable=\"true\"]' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ! isSelected ) {\n\t\t\t\t// We know for certain that on focus, the old selection is invalid.\n\t\t\t\t// It will be recalculated on the next mouseup, keyup, or touchend\n\t\t\t\t// event.\n\t\t\t\tconst index = undefined;\n\n\t\t\t\trecord.current = {\n\t\t\t\t\t...record.current,\n\t\t\t\t\tstart: index,\n\t\t\t\t\tend: index,\n\t\t\t\t\tactiveFormats: EMPTY_ACTIVE_FORMATS,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tapplyRecord( record.current, { domOnly: true } );\n\t\t\t}\n\n\t\t\tonSelectionChange( record.current.start, record.current.end );\n\n\t\t\townerDocument.addEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t}\n\n\t\telement.addEventListener( 'input', onInput );\n\t\telement.addEventListener( 'compositionstart', onCompositionStart );\n\t\telement.addEventListener( 'compositionend', onCompositionEnd );\n\t\telement.addEventListener( 'focus', onFocus );\n\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'input', onInput );\n\t\t\telement.removeEventListener(\n\t\t\t\t'compositionstart',\n\t\t\t\tonCompositionStart\n\t\t\t);\n\t\t\telement.removeEventListener( 'compositionend', onCompositionEnd );\n\t\t\telement.removeEventListener( 'focus', onFocus );\n\t\t};\n\t}, [] );\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Efficiently updates all the formats from `start` (including) until `end`\n * (excluding) with the active formats. Mutates `value`.\n *\n * @param {Object}        $1         Named paramentes.\n * @param {RichTextValue} $1.value   Value te update.\n * @param {number}        $1.start   Index to update from.\n * @param {number}        $1.end     Index to update until.\n * @param {Array}         $1.formats Replacement formats.\n *\n * @return {RichTextValue} Mutated value.\n */\nexport function updateFormats( { value, start, end, formats } ) {\n\t// Start and end may be switched in case of delete.\n\tconst min = Math.min( start, end );\n\tconst max = Math.max( start, end );\n\tconst formatsBefore = value.formats[ min - 1 ] || [];\n\tconst formatsAfter = value.formats[ max ] || [];\n\n\t// First, fix the references. If any format right before or after are\n\t// equal, the replacement format should use the same reference.\n\tvalue.activeFormats = formats.map( ( format, index ) => {\n\t\tif ( formatsBefore[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsBefore[ index ] ) ) {\n\t\t\t\treturn formatsBefore[ index ];\n\t\t\t}\n\t\t} else if ( formatsAfter[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsAfter[ index ] ) ) {\n\t\t\t\treturn formatsAfter[ index ];\n\t\t\t}\n\t\t}\n\n\t\treturn format;\n\t} );\n\n\twhile ( --end >= start ) {\n\t\tif ( value.activeFormats.length > 0 ) {\n\t\t\tvalue.formats[ end ] = value.activeFormats;\n\t\t} else {\n\t\t\tdelete value.formats[ end ];\n\t\t}\n\t}\n\n\treturn value;\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\nimport { BACKSPACE, DELETE } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { remove } from '../remove';\n\nexport function useDelete( props ) {\n\tconst propsRef = useRef( props );\n\tpropsRef.current = props;\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onKeyDown( event ) {\n\t\t\tconst { keyCode } = event;\n\t\t\tconst { createRecord, handleChange } = propsRef.current;\n\n\t\t\tif ( event.defaultPrevented ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( keyCode !== DELETE && keyCode !== BACKSPACE ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentValue = createRecord();\n\t\t\tconst { start, end, text } = currentValue;\n\n\t\t\t// Always handle full content deletion ourselves.\n\t\t\tif ( start === 0 && end !== 0 && end === text.length ) {\n\t\t\t\thandleChange( remove( currentValue ) );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\n\t\telement.addEventListener( 'keydown', onKeyDown );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t\t};\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useRef, useLayoutEffect, useReducer } from '@wordpress/element';\nimport { useMergeRefs, useRefEffect } from '@wordpress/compose';\nimport { useRegistry } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { create, RichTextData } from '../create';\nimport { apply } from '../to-dom';\nimport { toHTMLString } from '../to-html-string';\nimport { useDefaultStyle } from './use-default-style';\nimport { useBoundaryStyle } from './use-boundary-style';\nimport { useCopyHandler } from './use-copy-handler';\nimport { useFormatBoundaries } from './use-format-boundaries';\nimport { useSelectObject } from './use-select-object';\nimport { useInputAndSelection } from './use-input-and-selection';\nimport { useSelectionChangeCompat } from './use-selection-change-compat';\nimport { useDelete } from './use-delete';\n\nexport function useRichText( {\n\tvalue = '',\n\tselectionStart,\n\tselectionEnd,\n\tplaceholder,\n\tonSelectionChange,\n\tpreserveWhiteSpace,\n\tonChange,\n\t__unstableDisableFormats: disableFormats,\n\t__unstableIsSelected: isSelected,\n\t__unstableDependencies = [],\n\t__unstableAfterParse,\n\t__unstableBeforeSerialize,\n\t__unstableAddInvisibleFormats,\n} ) {\n\tconst registry = useRegistry();\n\tconst [ , forceRender ] = useReducer( () => ( {} ) );\n\tconst ref = useRef();\n\n\tfunction createRecord() {\n\t\tconst {\n\t\t\townerDocument: { defaultView },\n\t\t} = ref.current;\n\t\tconst selection = defaultView.getSelection();\n\t\tconst range =\n\t\t\tselection.rangeCount > 0 ? selection.getRangeAt( 0 ) : null;\n\n\t\treturn create( {\n\t\t\telement: ref.current,\n\t\t\trange,\n\t\t\t__unstableIsEditableTree: true,\n\t\t} );\n\t}\n\n\tfunction applyRecord( newRecord, { domOnly } = {} ) {\n\t\tapply( {\n\t\t\tvalue: newRecord,\n\t\t\tcurrent: ref.current,\n\t\t\tprepareEditableTree: __unstableAddInvisibleFormats,\n\t\t\t__unstableDomOnly: domOnly,\n\t\t\tplaceholder,\n\t\t} );\n\t}\n\n\t// Internal values are updated synchronously, unlike props and state.\n\tconst _value = useRef( value );\n\tconst record = useRef();\n\n\tfunction setRecordFromProps() {\n\t\t_value.current = value;\n\t\trecord.current = value;\n\t\tif ( ! ( value instanceof RichTextData ) ) {\n\t\t\trecord.current = value\n\t\t\t\t? RichTextData.fromHTMLString( value, { preserveWhiteSpace } )\n\t\t\t\t: RichTextData.empty();\n\t\t}\n\t\t// To do: make rich text internally work with RichTextData.\n\t\trecord.current = {\n\t\t\ttext: record.current.text,\n\t\t\tformats: record.current.formats,\n\t\t\treplacements: record.current.replacements,\n\t\t};\n\t\tif ( disableFormats ) {\n\t\t\trecord.current.formats = Array( value.length );\n\t\t\trecord.current.replacements = Array( value.length );\n\t\t}\n\t\tif ( __unstableAfterParse ) {\n\t\t\trecord.current.formats = __unstableAfterParse( record.current );\n\t\t}\n\t\trecord.current.start = selectionStart;\n\t\trecord.current.end = selectionEnd;\n\t}\n\n\tconst hadSelectionUpdate = useRef( false );\n\n\tif ( ! record.current ) {\n\t\thadSelectionUpdate.current = isSelected;\n\t\tsetRecordFromProps();\n\t} else if (\n\t\tselectionStart !== record.current.start ||\n\t\tselectionEnd !== record.current.end\n\t) {\n\t\thadSelectionUpdate.current = isSelected;\n\t\trecord.current = {\n\t\t\t...record.current,\n\t\t\tstart: selectionStart,\n\t\t\tend: selectionEnd,\n\t\t\tactiveFormats: undefined,\n\t\t};\n\t}\n\n\t/**\n\t * Sync the value to global state. The node tree and selection will also be\n\t * updated if differences are found.\n\t *\n\t * @param {Object} newRecord The record to sync and apply.\n\t */\n\tfunction handleChange( newRecord ) {\n\t\trecord.current = newRecord;\n\t\tapplyRecord( newRecord );\n\n\t\tif ( disableFormats ) {\n\t\t\t_value.current = newRecord.text;\n\t\t} else {\n\t\t\tconst newFormats = __unstableBeforeSerialize\n\t\t\t\t? __unstableBeforeSerialize( newRecord )\n\t\t\t\t: newRecord.formats;\n\t\t\tnewRecord = { ...newRecord, formats: newFormats };\n\t\t\tif ( typeof value === 'string' ) {\n\t\t\t\t_value.current = toHTMLString( {\n\t\t\t\t\tvalue: newRecord,\n\t\t\t\t\tpreserveWhiteSpace,\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t_value.current = new RichTextData( newRecord );\n\t\t\t}\n\t\t}\n\n\t\tconst { start, end, formats, text } = record.current;\n\n\t\t// Selection must be updated first, so it is recorded in history when\n\t\t// the content change happens.\n\t\t// We batch both calls to only attempt to rerender once.\n\t\tregistry.batch( () => {\n\t\t\tonSelectionChange( start, end );\n\t\t\tonChange( _value.current, {\n\t\t\t\t__unstableFormats: formats,\n\t\t\t\t__unstableText: text,\n\t\t\t} );\n\t\t} );\n\t\tforceRender();\n\t}\n\n\tfunction applyFromProps() {\n\t\tsetRecordFromProps();\n\t\tapplyRecord( record.current );\n\t}\n\n\tconst didMount = useRef( false );\n\n\t// Value updates must happen synchonously to avoid overwriting newer values.\n\tuseLayoutEffect( () => {\n\t\tif ( didMount.current && value !== _value.current ) {\n\t\t\tapplyFromProps();\n\t\t\tforceRender();\n\t\t}\n\t}, [ value ] );\n\n\t// Value updates must happen synchonously to avoid overwriting newer values.\n\tuseLayoutEffect( () => {\n\t\tif ( ! hadSelectionUpdate.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ref.current.ownerDocument.activeElement !== ref.current ) {\n\t\t\tref.current.focus();\n\t\t}\n\n\t\tapplyRecord( record.current );\n\t\thadSelectionUpdate.current = false;\n\t}, [ hadSelectionUpdate.current ] );\n\n\tconst mergedRefs = useMergeRefs( [\n\t\tref,\n\t\tuseDefaultStyle(),\n\t\tuseBoundaryStyle( { record } ),\n\t\tuseCopyHandler( { record } ),\n\t\tuseSelectObject(),\n\t\tuseFormatBoundaries( { record, applyRecord } ),\n\t\tuseDelete( {\n\t\t\tcreateRecord,\n\t\t\thandleChange,\n\t\t} ),\n\t\tuseInputAndSelection( {\n\t\t\trecord,\n\t\t\tapplyRecord,\n\t\t\tcreateRecord,\n\t\t\thandleChange,\n\t\t\tisSelected,\n\t\t\tonSelectionChange,\n\t\t} ),\n\t\tuseSelectionChangeCompat(),\n\t\tuseRefEffect( () => {\n\t\t\tapplyFromProps();\n\t\t\tdidMount.current = true;\n\t\t}, [ placeholder, ...__unstableDependencies ] ),\n\t] );\n\n\treturn {\n\t\tvalue: record.current,\n\t\t// A function to get the most recent value so event handlers in\n\t\t// useRichText implementations have access to it. For example when\n\t\t// listening to input events, we internally update the state, but this\n\t\t// state is not yet available to the input event handler because React\n\t\t// may re-render asynchronously.\n\t\tgetValue: () => record.current,\n\t\tonChange: handleChange,\n\t\tref: mergedRefs,\n\t};\n}\n\nexport default function __experimentalRichText() {}\n","/**\n * WordPress dependencies\n */\nimport { useRefEffect } from '@wordpress/compose';\n\nexport function useSelectObject() {\n\treturn useRefEffect( ( element ) => {\n\t\tfunction onClick( event ) {\n\t\t\tconst { target } = event;\n\n\t\t\t// If the child element has no text content, it must be an object.\n\t\t\tif (\n\t\t\t\ttarget === element ||\n\t\t\t\t( target.textContent && target.isContentEditable )\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { ownerDocument } = target;\n\t\t\tconst { defaultView } = ownerDocument;\n\t\t\tconst selection = defaultView.getSelection();\n\n\t\t\t// If it's already selected, do nothing and let default behavior\n\t\t\t// happen. This means it's \"click-through\".\n\t\t\tif ( selection.containsNode( target ) ) return;\n\n\t\t\tconst range = ownerDocument.createRange();\n\t\t\t// If the target is within a non editable element, select the non\n\t\t\t// editable element.\n\t\t\tconst nodeToSelect = target.isContentEditable\n\t\t\t\t? target\n\t\t\t\t: target.closest( '[contenteditable]' );\n\n\t\t\trange.selectNode( nodeToSelect );\n\t\t\tselection.removeAllRanges();\n\t\t\tselection.addRange( range );\n\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\tfunction onFocusIn( event ) {\n\t\t\t// When there is incoming focus from a link, select the object.\n\t\t\tif (\n\t\t\t\tevent.relatedTarget &&\n\t\t\t\t! element.contains( event.relatedTarget ) &&\n\t\t\t\tevent.relatedTarget.tagName === 'A'\n\t\t\t) {\n\t\t\t\tonClick( event );\n\t\t\t}\n\t\t}\n\n\t\telement.addEventListener( 'click', onClick );\n\t\telement.addEventListener( 'focusin', onFocusIn );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'click', onClick );\n\t\t\telement.removeEventListener( 'focusin', onFocusIn );\n\t\t};\n\t}, [] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { isRangeEqual } from '../is-range-equal';\n\n/**\n * Sometimes some browsers are not firing a `selectionchange` event when\n * changing the selection by mouse or keyboard. This hook makes sure that, if we\n * detect no `selectionchange` or `input` event between the up and down events,\n * we fire a `selectionchange` event.\n *\n * @return {import('@wordpress/compose').RefEffect} A ref effect attaching the\n *                                                  listeners.\n */\nexport function useSelectionChangeCompat() {\n\treturn useRefEffect( ( element ) => {\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\t\tconst selection = defaultView?.getSelection();\n\n\t\tlet range;\n\n\t\tfunction getRange() {\n\t\t\treturn selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\t\t}\n\n\t\tfunction onDown( event ) {\n\t\t\tconst type = event.type === 'keydown' ? 'keyup' : 'pointerup';\n\n\t\t\tfunction onCancel() {\n\t\t\t\townerDocument.removeEventListener( type, onUp );\n\t\t\t\townerDocument.removeEventListener(\n\t\t\t\t\t'selectionchange',\n\t\t\t\t\tonCancel\n\t\t\t\t);\n\t\t\t\townerDocument.removeEventListener( 'input', onCancel );\n\t\t\t}\n\n\t\t\tfunction onUp() {\n\t\t\t\tonCancel();\n\t\t\t\tif ( isRangeEqual( range, getRange() ) ) return;\n\t\t\t\townerDocument.dispatchEvent( new Event( 'selectionchange' ) );\n\t\t\t}\n\n\t\t\townerDocument.addEventListener( type, onUp );\n\t\t\townerDocument.addEventListener( 'selectionchange', onCancel );\n\t\t\townerDocument.addEventListener( 'input', onCancel );\n\n\t\t\trange = getRange();\n\t\t}\n\n\t\telement.addEventListener( 'pointerdown', onDown );\n\t\telement.addEventListener( 'keydown', onDown );\n\t\treturn () => {\n\t\t\telement.removeEventListener( 'pointerdown', onDown );\n\t\t\telement.removeEventListener( 'keydown', onDown );\n\t\t};\n\t}, [] );\n}\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","window","combineReducers","formatTypes","state","action","type","reduce","newFormatTypes","name","fromEntries","entries","filter","names","includes","LEAF_KEY","arrayOf","isShallowEqual","b","fromIndex","i","length","getFormatTypes","selector","getDependants","rootCache","normalizedGetDependants","clear","WeakMap","callSelector","cache","node","args","dependants","len","arguments","Array","dependant","map","caches","isUniqueByDependants","has","set","head","createCache","getCache","apply","lastDependants","next","prev","val","createSelector","values","getFormatType","getFormatTypeForBareElement","bareElementTagName","find","className","tagName","getFormatTypeForClassName","elementClassName","indexOf","addFormatTypes","isArray","removeFormatTypes","store","createReduxStore","reducer","selectors","actions","isFormatEqual","format1","format2","attributes1","attributes","attributes2","keys1","keys","keys2","normaliseFormats","newFormats","formats","slice","forEach","formatsAtIndex","index","formatsAtPreviousIndex","newFormatsAtIndex","format","formatIndex","previousFormat","replace","array","applyFormat","startIndex","start","endIndex","end","activeFormats","startFormat","position","splice","createElement","implementation","html","body","createHTMLDocument","innerHTML","register","OBJECT_REPLACEMENT_CHARACTER","ZWNBSP","getActiveFormats","EMPTY_ACTIVE_FORMATS","undefined","formatsBefore","formatsAfter","selectedFormats","_activeFormats","ii","_format","select","richTextStore","restoreOnAttributes","isEditableTree","newAttributes","newKey","startsWith","fromFormat","unregisteredAttributes","object","boundaryClass","formatType","elementAttributes","class","contentEditable","contenteditable","isEqualUntil","toTree","preserveWhiteSpace","createEmpty","append","getLastChild","getParent","isText","getText","remove","appendText","onStartIndex","onEndIndex","placeholder","replacements","text","formatsLength","tree","deepestActiveFormat","lastCharacterFormats","lastCharacter","character","charAt","shouldInsertPadding","characterFormats","pointer","parent","newNode","replacement","decodeURIComponent","style","toHTMLString","createChildrenHTML","children","push","child","attributeString","isValidAttributeName","escapeAttribute","createElementHTML","escapeEditableHTML","join","getTextContent","toFormat","trim","__experimentalCreatePrepareEditableTree","__experimentalCreateOnChangeEditableValue","registeredAttributes","_attributes","RichTextData","empty","fromPlainText","create","fromHTMLString","fromHTMLElement","htmlElement","options","element","collapseWhiteSpace","richTextData","constructor","init","this","toPlainText","originalHTML","valueOf","toString","toJSON","getOwnPropertyNames","String","range","__unstableIsEditableTree","document","createFromElement","accumulateSelection","accumulator","parentNode","startContainer","startOffset","endContainer","endOffset","currentLength","nodeType","TEXT_NODE","childNodes","filterRange","nodeValue","isRoot","clone","cloneNode","normalize","from","nodes","newNodeValue","test","endsWith","ELEMENT_NODE","CARRIAGE_RETURN","removeReservedCharacters","string","RegExp","hasChildNodes","nodeName","toLowerCase","getAttribute","encodeURIComponent","mergePair","getAttributes","mergeFormats","hasAttributes","concat","getActiveFormat","getActiveObject","isCollapsed","isEmpty","separator","accumlator","registerFormatType","settings","console","error","formatTypeForBareElement","formatTypeForClassName","title","keywords","dispatch","removeFormat","newFormat","filterFormats","insert","valueToInsert","pattern","match","rest","offset","newReplacements","newText","fill","insertObject","formatToInsert","split","splitAtSelection","nextStart","substring","isRangeEqual","createPathToNode","rootNode","path","previousSibling","getNodeByPath","shift","ownerDocument","createTextNode","setAttribute","appendChild","appendData","lastChild","removeChild","toDom","prepareEditableTree","doc","startPath","endPath","selection","current","__unstableDomOnly","applyValue","defaultView","getSelection","createRange","setStart","setEnd","activeElement","rangeCount","getRangeAt","removeAllRanges","addRange","HTMLElement","focus","applySelection","future","futureChild","firstChild","currentChild","isEqualNode","data","replaceChild","currentAttributes","futureAttributes","removeAttribute","toggleFormat","speak","sprintf","__","unregisterFormatType","oldFormat","useAnchorRef","ref","deprecated","since","alternative","activeFormat","useMemo","nextElementSibling","closest","getAnchor","editableContentElement","formatElement","nextSibling","parentElement","contains","matches","getFormatElement","contextElement","getBoundingClientRect","createVirtualAnchorElement","useAnchor","isActive","anchor","setAnchor","useState","wasActive","usePrevious","useLayoutEffect","callback","attach","addEventListener","detach","removeEventListener","whiteSpace","minWidth","useBoundaryStyle","record","useRef","activeReplacement","useEffect","boundarySelector","querySelector","getComputedStyle","color","globalStyleId","globalStyle","getElementById","id","useCopyHandler","props","propsRef","useRefEffect","onCopy","event","selectedRecord","plainText","clipboardData","setData","preventDefault","execCommand","useFormatBoundaries","forceRender","useReducer","onKeyDown","keyCode","shiftKey","altKey","metaKey","ctrlKey","LEFT","RIGHT","applyRecord","currentActiveFormats","collapsed","direction","reverseKey","isReverse","destination","isIncreasing","every","newActiveFormatsLength","_newActiveFormats","newActiveFormats","newValue","INSERTION_INPUT_TYPES_TO_IGNORE","Set","PLACEHOLDER_ATTR_NAME","useInputAndSelection","isComposing","onInput","inputType","createRecord","handleChange","currentValue","oldActiveFormats","change","min","Math","max","updateFormats","handleSelectionChange","onSelectionChange","oldRecord","anchorNode","anchorOffset","targetNode","hasAttribute","collapseToStart","fixPlaceholderSelection","domOnly","onCompositionStart","onCompositionEnd","onFocus","isSelected","useDelete","defaultPrevented","DELETE","BACKSPACE","useRichText","selectionStart","selectionEnd","onChange","__unstableDisableFormats","disableFormats","__unstableIsSelected","__unstableDependencies","__unstableAfterParse","__unstableBeforeSerialize","__unstableAddInvisibleFormats","registry","useRegistry","newRecord","_value","setRecordFromProps","hadSelectionUpdate","batch","__unstableFormats","__unstableText","applyFromProps","didMount","mergedRefs","useMergeRefs","useCallback","onClick","target","textContent","isContentEditable","containsNode","nodeToSelect","selectNode","onFocusIn","relatedTarget","getRange","onDown","onCancel","onUp","dispatchEvent","Event","getValue","__experimentalRichText"],"sourceRoot":""}